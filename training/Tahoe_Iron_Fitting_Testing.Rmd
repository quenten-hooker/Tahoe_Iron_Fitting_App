---
title: "Tahoe Iron Fitting App - Data format and test"
author: "Quenten Hooker"
date: "4/17/2023"
output: 
  pdf_document: default
  html_document:
    df_print: paged
  word_document: default
  html_notebook: default
urlcolor: blue
---

- Goal
- someone enter in a few swing parameters and give downrange and trajectory data for a few clubs

```{r , echo=FALSE, include = FALSE, warning=FALSE}

# library("ggplot2")
# library("lme4")
# library("car")
# library("dplyr")
# library("tidyr")
# library("lmerTest")
# library("ggpubr")
# library("GGally")
# library("emmeans")
# library("olsrr")
# library("readxl")
# library("ggforce")
# library("psych")
# library("jtools")
# library("sjPlot")
# library("sjmisc")
# library("kableExtra")
# library("knitr")
# library("sp")
# library("plotly")
# library("reshape2")
# library("ggeffects")
# library("MuMIn")
# library('lubridate')
# library('xlsx')
# library('stringi')
# library('fuzzyjoin')
# library('stringdist')
library('reticulate')
# library('stringr')

#pacman::p_load(ggplot2, dplyr, tidyr, ggpubr, sjPlot, kableExtra, sp, plotly, ggeffects, akima, lme4, stringr, reshape)
library("dplyr")
library("reshape")
library("ggplot2")
library("lme4")
library("sjPlot")
library("ggeffects")

library("ggplot2")
library('tidyr')
library("dplyr")
library("reticulate")
library('lme4')
library('DT')
library('ggeffects')
library('shiny')
library('shinyWidgets')
library('shinythemes')
library('plotly')
library('caTools')
library('randomForest')

```

#Glob and format to merge Core panel data
```{r , echo=TRUE, include = TRUE}

# Path <- "E:/4716/Shared Documents/91362/05 - Player Test/"
# 
# dat.files  <- list.files(path= Path,
#                                recursive=T,
#                                pattern=c(".csv"),
#                                full.names=T)
# 
# #function for reading each cg/moi
# readDatFile <- function(f) {
#   #dat.fl <- read_excel(path = f, sheet= 1, col_names = TRUE, skip = 0)
#   dat.fl <- read.csv(f, header = TRUE, sep=",", skip = 4,  
#                na.strings=c("NA","NaN"," ",""))
# }
# 
# Data.Quad <- c()
#   
# #Look for sheet names to help scraper 
# for (i in 1:length(dat.files)) {
#  
#   temp <- readDatFile(dat.files[i])
#   temp$Player <- sub(".*/", "", dat.files[i])
#   temp$Player <-  substr(temp$Player, 1, nchar(temp$Player)-4)
#   Data.Quad <- rbind(Data.Quad, temp)
#   
# }
# 
# Data.Quad 
# 
# Data.Quad$Club[Data.Quad$Club.ID == "Club A"] <- "AW"
# Data.Quad$Club[Data.Quad$Club.ID == "Club B"] <- "9 Iron"
# Data.Quad$Club[Data.Quad$Club.ID == "Club C"] <- "AW"
# Data.Quad$Club[Data.Quad$Club.ID == "Club D"] <- "9 Iron"
# 
# Data.Quad$Model[Data.Quad$Club.ID == "Club D" | Data.Quad$Club.ID == "Club C" ] <- "Tahoe HL"
# Data.Quad$Model[Data.Quad$Club.ID == "Club A" | Data.Quad$Club.ID == "Club B" ] <- "Tahoe Std"
# 
# #Data.Quad.03 <- Data.Quad
# #Data.Quad.04 <- Data.Quad
# #Data.Quad.05 <- Data.Quad
# 
# Data.Combined <- rbind(Data.Quad.03, Data.Quad.04, Data.Quad.05)
# Data.Combined$Tags <- Data.Combined$Model
# Data.Combined$FullTag <- paste(Data.Combined$Club, Data.Combined$Model, sep = ", " )
# 
# Data.Combined <- Data.Combined %>% relocate(Player, Club, Tags, FullTag) %>% relocate(Time, .after = Vertical.Face.Impact..mm.....is.up.) %>% relocate(Shot.Color..R.G.B., .after = Time)
# 
# col_names <- c("Player", "Club", "Tags", "FullTag", "Shot.ID", "Selected", "Date.quad", "Club.Type", "Club.ID", "Range.Ball.quad", "Ball.Speed.quad","Launch.Angle.quad", "Side.Angle.quad", "Side.Spin.quad", "Back.Spin.quad", "Tilt.Angle.quad", "Spin.Rate.quad", "Peak.Height.quad", "Carry.quad", "Range.quad", "Offline.quad", "Descent.Angle.quad", "Club.Speed.quad" ,"Efficiency.quad", "Angle.Of.Attack.quad", "Club.Path.quad", "Face.To.Target.quad", "Face.To.Path.quad", "Lie.quad", "Loft.quad", "Closing.Rate.quad", "Impact.Speed.quad", "Lateral.Face.quad", "Vertical.Face.quad", "Time", "Shot.Color", "Model")
# colnames(Data.Combined) <- col_names
# 
# #write.csv(Data.Combined, "Core_Panel_Glob.csv")

```


```{r , echo=FALSE, include = TRUE, warning=FALSE}

player_speed <- 98.3
player_attack <- -4.8
player_pitch <- -7.0	

```

# Read data and reformat
```{r , echo=FALSE, include = TRUE, warning=FALSE}

Data <- read.csv('Gold_Panel_Glob.csv')

col_names <- c("Player", "Club", "Tags", "FullTag", "Shot.ID", "Selected", "Date.quad", "Club.Type", "Club.ID", "Range.Ball.quad", "Ball.Speed.quad","Launch.Angle.quad", "Side.Angle.quad", "Side.Spin.quad", "Back.Spin.quad", "Tilt.Angle.quad", "Spin.Rate.quad", "Peak.Height.quad", "Carry.quad", "Range.quad", "Offline.quad", "Descent.Angle.quad", "Club.Speed.quad" ,"Efficiency.quad", "Angle.Of.Attack.quad", "Club.Path.quad", "Face.To.Target.quad", "Face.To.Path.quad", "Lie.quad", "Loft.quad", "Closing.Rate.quad", "Impact.Speed.quad", "Lateral.Face.quad", "Vertical.Face.quad", "Time", "Shot.Color")

colnames(Data) <- col_names

Data$Model <- Data$Tags

Data.core <- read.csv('Core_Panel_Glob.csv')
Data <- rbind(Data, Data.core)

Data %>% group_by(Tags) %>% summarise(n())
Data %>% group_by(Player) %>% summarise(n())

Data %>% filter(Model == "Tahoe HL") %>% group_by(Club) %>% summarise(n())

Data %>% group_by(Club) %>% filter_if(~is.numeric(.), all_vars(!is.infinite(.))) %>% summarise(Carry.quad = mean(na.omit(Carry.quad))) %>% arrange(desc(Carry.quad))

#Data %>% group_by(Length) %>% filter_if(~is.numeric(.), all_vars(!is.infinite(.))) %>% summarise(Vertical.Face.quad = mean(na.omit(Vertical.Face.quad)), Club.Speed.quad = mean(na.omit(Club.Speed.quad)), Angle.Of.Attack.quad = mean(na.omit(Angle.Of.Attack.quad)), Loft.quad = mean(na.omit(Loft.quad - Static.Loft))) 


```

#Creating length and static loft columns
```{r , echo=FALSE, include = TRUE, warning=FALSE}

Data$Length[Data$Club== "PW"] <- 35.75
Data$Length[Data$Club== "9 Iron"] <- 36.0
Data$Length[Data$Club== "8 Iron"] <- 36.5
Data$Length[Data$Club== "7 Iron"] <- 37.0
Data$Length[Data$Club== "6 Iron"] <- 37.5
Data$Length[Data$Club== "5 Iron"] <- 38.0

Data$Length[Data$Club== "AW" & Data$Model == "Tahoe Std"] <- 35.5
Data$Length[Data$Club== "9 Iron" & Data$Model == "Tahoe Std"] <- 36.0
Data$Length[Data$Club== "7 Iron" & Data$Model == "Tahoe Std"] <- 37.25
Data$Length[Data$Club== "5 Iron" & Data$Model == "Tahoe Std"] <- 38.5

Data$Length[Data$Club== "AW" & Data$Model == "Tahoe HL"] <- 35.5
Data$Length[Data$Club== "9 Iron" & Data$Model == "Tahoe HL"] <- 36.0
Data$Length[Data$Club== "7 Iron" & Data$Model == "Tahoe HL"] <- 37.5
Data$Length[Data$Club== "5 Iron" & Data$Model == "Tahoe HL"] <- 39.0

Data$Length[Data$Club== "PW"] <- 35.75
Data$Length[Data$Club== "9 Iron"] <- 36.0
Data$Length[Data$Club== "8 Iron"] <- 36.5
Data$Length[Data$Club== "7 Iron"] <- 37.0
Data$Length[Data$Club== "6 Iron"] <- 37.5
Data$Length[Data$Club== "5 Iron"] <- 38.0

Data$Static.Loft[Data$Club == "PW" & Data$Model == "TCB"] <- 46.75
Data$Static.Loft[Data$Club == "9 Iron" & Data$Model == "TCB"] <- 42.5
Data$Static.Loft[Data$Club == "8 Iron" & Data$Model == "TCB"] <- 39
Data$Static.Loft[Data$Club == "7 Iron" & Data$Model == "TCB"] <- 34.75
Data$Static.Loft[Data$Club == "6 Iron" & Data$Model == "TCB"] <- 30.25
Data$Static.Loft[Data$Club == "5 Iron" & Data$Model == "TCB"] <- 26.5

Data$Static.Loft[Data$Club == "PW" & Data$Model == "MB21"] <- 46
Data$Static.Loft[Data$Club == "9 Iron" & Data$Model == "MB21"] <- 42.5
Data$Static.Loft[Data$Club == "8 Iron" & Data$Model == "MB21"] <- 38.25
Data$Static.Loft[Data$Club == "7 Iron" & Data$Model == "MB21"] <- 34.25
Data$Static.Loft[Data$Club == "6 Iron" & Data$Model == "MB21"] <- 30.5
Data$Static.Loft[Data$Club == "5 Iron" & Data$Model == "MB21"] <- 26.25

Data$Static.Loft[Data$Club == "AW" & Data$Model == "Tahoe Std"] <- 47.0
Data$Static.Loft[Data$Club == "9 Iron" & Data$Model == "Tahoe Std"] <- 37.0
Data$Static.Loft[Data$Club == "7 Iron" & Data$Model == "Tahoe Std"] <- 29.0
Data$Static.Loft[Data$Club == "5 Iron" & Data$Model == "Tahoe Std"] <- 23.0

Data$Static.Loft[Data$Club == "AW" & Data$Model == "Tahoe HL"] <- 48.0
Data$Static.Loft[Data$Club == "9 Iron" & Data$Model == "Tahoe HL"] <- 38.0
Data$Static.Loft[Data$Club == "7 Iron" & Data$Model == "Tahoe HL"] <- 30.0
Data$Static.Loft[Data$Club == "5 Iron" & Data$Model == "Tahoe HL"] <- 24.0

```

```{r , echo=FALSE, include = TRUE, warning=FALSE}

Data <- within(Data, {
  Player <- factor(Player)
  Club <- factor(Club)
  Club.Speed.quad <- as.numeric(Club.Speed.quad)
  Efficiency.quad <- as.numeric(Efficiency.quad)
  Angle.Of.Attack.quad <- as.numeric(Angle.Of.Attack.quad)
  Club.Path.quad <- as.numeric(Club.Path.quad)
  Face.To.Target.quad <- as.numeric(Face.To.Target.quad)
  Face.To.Path.quad <- as.numeric(Face.To.Path.quad)
  Lie.quad <- as.numeric(Lie.quad)
  Loft.quad <- as.numeric(Loft.quad)
  Lateral.Face.quad <- as.numeric(Lateral.Face.quad)*-1
  Vertical.Face.quad <- as.numeric(Vertical.Face.quad)
  })

Data$Pitch <- Data$Loft.quad - Data$Static.Loft
Data.Combined <- Data

```


# Filtering functions
```{r , echo=FALSE, include = TRUE, warning=FALSE}

# create detect outlier function
# detect_outlier <- function(x) {
# 
# 	# calculate first quantile
# 	Quantile1 <- quantile(x %>% na.omit(), probs=.25)
# 
# 	# calculate third quantile
# 	Quantile3 <- quantile(x %>% na.omit(), probs=.75)
# 
# 	# calculate inter quartile range
# 	IQR = Quantile3-Quantile1
# 
# 	# return true or false
# 	x > Quantile3 + (IQR*1.5) | x < Quantile1 - (IQR*1.5)
# }
# 
# # create remove outlier function
# remove_outlier <- function(dataframe,
# 							columns=names(dataframe)) {
# 
# 	# for loop to traverse in columns vector
# 	for (col in columns) {
# 
# 		# remove observation if it satisfies outlier function
# 		temp <- !detect_outlier(dataframe[[col]])
# 		temp[temp = NA] <- TRUE
# 	  dataframe <- dataframe[, ]
# 	}
# 
# 	# return dataframe
# 	print("Remove outliers")
# 	print(dataframe)
# }

```


```{r , echo=FALSE, include = TRUE, warning=FALSE}

data_long_ball <- melt(Data.Combined %>% select(Ball.Speed.quad, Launch.Angle.quad, Side.Angle.quad, Side.Spin.quad, Back.Spin.quad))

data_long_club <- melt(Data.Combined %>% select(Club.Speed.quad, Angle.Of.Attack.quad, Club.Path.quad, Face.To.Target.quad, Face.To.Path.quad, Lie.quad, Pitch, Lateral.Face.quad, Vertical.Face.quad))

ggplot(data_long_ball, aes(x=value,)) + geom_boxplot() + facet_wrap(~variable, scale="free")
ggplot(data_long_club, aes(x=value,)) + geom_boxplot() + facet_wrap(~variable, scale="free")

Data.Combined <- Data.Combined %>% filter(Ball.Speed.quad > 50, Launch.Angle.quad < 50, Side.Angle.quad < 25, Side.Spin.quad < 2000, Back.Spin.quad > 3000, Face.To.Target.quad < 15, Face.To.Target.quad > -15, Lie.quad < 20, Lie.quad > -20, Pitch > -25, Pitch < 0, Lateral.Face.quad > -20, Lateral.Face.quad < 20, Vertical.Face.quad < 10, Vertical.Face.quad > -30)

```

# Modeling dynamics
```{r , echo=FALSE, include = TRUE, warning=FALSE}

ggplot(Data.Combined, aes(x = Length, y = Club.Speed.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7))

ggplot(Data.Combined, aes(x = Length, y = Club.Speed.quad)) + geom_point() + geom_smooth(method = 'loess', formula = 'y~x') 

lm.Club.Speed.quad <-lmer(Club.Speed.quad ~
           # Fixed-effects
           1 + Length + I(Length^2) +
           # Random-effects
           (1 + Length + I(Length^2) | Player), data = Data.Combined)

lm.Club.Speed.quad <-lm(Club.Speed.quad ~
           # Fixed-effects
            1 + Length + I(Length^2), data = Data.Combined %>% filter(Player == "Jonathan Sanders"))

summary(lm.Club.Speed.quad)


plot_model(lm.Club.Speed.quad, type = "pred", terms = c("Length[all]"), ci.lvl = NA, show.data = TRUE)+theme_sjplot()

Data.Combined %>% group_by(Length) %>% summarise(mean(Vertical.Face.quad))


Hunter Reed, Jonathan Sanders	


saveRDS(lm.Club.Speed.quad, file = "mem_speed_TTB_test.rda")


Length = c(35.5, 35.75, 36.0, 36.5, 37.0, 37.5, 38.0, 38.5)
Club.Speed.quad = c(81, 83, 85, 87, 90, 92, 94, 96)
Attack.quad = c()

Data.test <- as.data.frame(cbind(Length, Club.Speed.quad))

lm.Club.Speed.quad <-lm(Club.Speed.quad ~
           # Fixed-effects
            1 + Length + I(Length^2), data = Data.test)

```




```{r , echo=FALSE, include = TRUE, warning=FALSE}


ggplot(Data.Combined, aes(x = Length, y = Angle.Of.Attack.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7))

ggplot(Data.Combined, aes(x = Length, y = Club.Path.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7)) 

ggplot(Data.Combined, aes(x = Length, y = Pitch)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7)) 

ggplot(Data.Combined, aes(x = Length, y = Ball.Speed.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7)) 

ggplot(Data.Combined, aes(x = Length, y = Launch.Angle.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7)) 

ggplot(Data.Combined, aes(x = Length, y = Back.Spin.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7)) 


ggplot(Data.Combined, aes(x = Length, y = Ball.Speed.quad)) + geom_point() + geom_smooth(method = 'loess', formula = 'y~x') 
ggplot(Data.Combined, aes(x = Length, y = Ball.Speed.quad)) + geom_point() + geom_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5), se=TRUE, level = .8, linetype = 1)

ggplot(Data.Combined, aes(x = Length, y = Launch.Angle.quad)) + geom_point() + geom_smooth(method = 'loess', formula = 'y~x') 
ggplot(Data.Combined, aes(x = Length, y = Back.Spin.quad)) + geom_point() + geom_smooth(method = 'loess', formula = 'y~x') 

#saveRDS(lm.Club.Speed.quad, file = "mem_speed_TTB_test.rda")

#saveRDS(lm.Pitch, file = "mem_pitch_TTB_test.rda")

#saveRDS(lm.Angle.Of.Attack.quad, file = "mem_attack_TTB_test.rda")

lm.Club.Speed.quad <-lmer(Club.Speed.quad ~
           # Fixed-effects
           1 + Length + I(Length^2) +
           # Random-effects
           (1 + Length | Player), data = Data.Combined)

lm.Angle.Of.Attack.quad <-lmer(Angle.Of.Attack.quad ~
           # Fixed-effects
           1 + Length +
           # Random-effects
           (1 + Length  | Player), data = Data.Combined)

lm.Pitch <-lmer(Pitch ~
           # Fixed-effects
           1 + Length  +
           # Random-effects
           (1 + Length  | Player), data = Data.Combined)

lm.Ball.Speed.quad <-lmer(Ball.Speed.quad ~
           # Fixed-effects
           1 + Length*Static.Loft + I(Length^2)*I(Static.Loft^2) +
           # Random-effects
           (1 + Length + Static.Loft | Player), data = Data.Combined)

plot_model(lm.Club.Speed.quad, type = "pred", terms = c("Length[all]"), ci.lvl = NA, show.data = TRUE)+theme_sjplot()
plot_model(lm.Ball.Speed.quad, type = "pred", terms = c("Length[all]"), ci.lvl = NA, show.data = TRUE)+theme_sjplot()
plot_model(lm.Ball.Speed.quad, type = "pred", terms = c("Static.Loft[all]"), ci.lvl = NA, show.data = TRUE)+theme_sjplot()
plot_model(lm.Angle.Of.Attack.quad, type = "pred", terms = c("Length[all]"), ci.lvl = NA, show.data = TRUE)+theme_sjplot()
plot_model(lm.Pitch, type = "pred", terms = c("Length[all]"), ci.lvl = NA, show.data = TRUE)+theme_sjplot()

plot_model(lm.Club.Speed.quad, type = "pred", pred.type = ("re"), terms = c("Length[all]", "Player"), show.data = FALSE, ci.lvl =NA)+theme_sjplot()
plot_model(lm.Ball.Speed.quad, type = "pred", pred.type = ("re"), terms = c("Length[all]", "Player"), show.data = FALSE, ci.lvl =NA)+theme_sjplot()

plot_model(lm.Angle.Of.Attack.quad, type = "pred", pred.type = ("re"), terms = c("Length[all]", "Player"), show.data = FALSE, ci.lvl =NA)+theme_sjplot()
plot_model(lm.Pitch, type = "pred", pred.type = ("re"), terms = c("Length[all]", "Player"), show.data = FALSE, ci.lvl =NA)+theme_sjplot()

```



```{r , echo=FALSE, include = FALSE, warning=FALSE, message = FALSE}

Data.Combined.train <- Data.Combined %>% filter(Model == "Tahoe Std" | Model == "Tahoe HL")

# Data.Combined.train$Model[Data.Combined.train$Model== "MB21"] <- "Tahoe (test)"
# Data.Combined.train$Model[Data.Combined.train$Model== "TCB"] <- "Tahoe HL (test)"

Data.Combined.train <- within(Data.Combined.train, {
  Model <- factor(as.character(Model))
  })

Data.Combined.train <-  Data.Combined.train %>% arrange(Player, Club, Model)
Data.Combined %>% group_by(Model) %>% summarise(n())

lm.Ball.Speed.normalize <-lmer(Ball.Speed.quad ~
           # Fixed-effects
           1 + Model + Club.Speed.quad + Pitch + Length:Club.Speed.quad + Length:Pitch + Vertical.Face.quad + Lateral.Face.quad +
             Model:Vertical.Face.quad + Model:Lateral.Face.quad + Model:I(Vertical.Face.quad^2) + Model:I(Lateral.Face.quad^2) +
           # Random-effects
           (1 + Club.Speed.quad + Pitch + Vertical.Face.quad + Lateral.Face.quad| Player), data = Data.Combined.train)

lm.Launch.Angle.normalize <-lmer(Launch.Angle.quad ~
                                   # Fixed-effects
                                   1 + Model + Club.Speed.quad + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad + Length:Pitch + Vertical.Face.quad + 
                                   Static.Loft:Club.Speed.quad + Static.Loft:Angle.Of.Attack.quad + Static.Loft:Pitch + Static.Loft:Vertical.Face.quad +
                                   # Random-effects
                                   (1 + Club.Speed.quad + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad| Player), data = Data.Combined.train)

lm.Back.Spin.normalize <-lmer(Back.Spin.quad ~
           # Fixed-effects
           1 + Model + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad +
             Length:Pitch + Length:Vertical.Face.quad + Static.Loft:Club.Speed.quad + Static.Loft:Vertical.Face.quad +
           # Random-effects
           (1 + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad| Player), data = Data.Combined.train)

lm.Side.Angle.normalize <-lmer(Side.Angle.quad ~
           # Fixed-effects
           1 + Length*Club.Speed.quad + Length*Face.To.Target.quad + Length*Lateral.Face.quad +
           # Random-effects
           (1 + Club.Speed.quad + Face.To.Target.quad + Lateral.Face.quad | Player), data = Data.Combined.train)

lm.Side.Spin.normalize <-lmer(Side.Spin.quad ~
           # Fixed-effects
           1 + Length*Club.Speed.quad + Length*Face.To.Path.quad + Length*Lateral.Face.quad  +
           # Random-effects
           (1 + Club.Speed.quad + Face.To.Path.quad + Lateral.Face.quad | Player), data = Data.Combined.train)


# saveRDS(lm.Ball.Speed.normalize, file = "MEM_bs_Tahoe.rda")
# saveRDS(lm.Launch.Angle.normalize, file = "mem_la_tahoe.rda")
# saveRDS(lm.Back.Spin.normalize, file = "mem_backs_tahoe.rda")
# saveRDS(lm.Side.Angle.normalize, file = "mem_sa_tahoe.rda")
# saveRDS(lm.Side.Spin.normalize, file = "mem_sides_tahoe.rda")

mean(na.omit(Data.Combined.train$Lie.quad))


```

## Ball Speed Evaluation
```{r , echo=FALSE, include = TRUE, warning=FALSE, , message = FALSE}

lm.Ball.Speed.normalize <-lmer(Ball.Speed.quad ~
           # Fixed-effects
           1 + Model + Club.Speed.quad + Pitch + Length:Club.Speed.quad + Length:Pitch + Vertical.Face.quad + Lateral.Face.quad +
             Model:Vertical.Face.quad + Model:Lateral.Face.quad + Model:I(Vertical.Face.quad^2) + Model:I(Lateral.Face.quad^2) +
           # Random-effects
           (1 + Club.Speed.quad + Pitch + Vertical.Face.quad + Lateral.Face.quad| Player), data = Data.Combined.train)

ggpredict(lm.Ball.Speed.normalize)

summary(lm.Ball.Speed.normalize)

plot_model(lm.Ball.Speed.normalize, type = "pred", terms = c("Club.Speed.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

# plot_model(lm.Ball.Speed.normalize, type = "pred", terms = c("Angle.Of.Attack.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Ball.Speed.normalize, type = "pred", terms = c("Pitch", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Ball.Speed.normalize, type = "pred", terms = c("Vertical.Face.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Ball.Speed.normalize, type = "pred", terms = c("Lateral.Face.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()


```


## Launch Angle Evaluation
```{r , echo=FALSE, include = TRUE, warning=FALSE, , message = FALSE}

lm.Launch.Angle.normalize <-lmer(Launch.Angle.quad ~
                                   # Fixed-effects
                                   1 + Model + Club.Speed.quad + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad + Length:Pitch + Vertical.Face.quad + 
                                   Static.Loft:Club.Speed.quad + Static.Loft:Angle.Of.Attack.quad + Static.Loft:Pitch + Static.Loft:Vertical.Face.quad +
                                   # Random-effects
                                   (1 + Club.Speed.quad + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad| Player), data = Data.Combined.train)

#summary(lm.Launch.Angle.normalize)

#ggpredict(lm.Launch.Angle.normalize)

plot_model(lm.Launch.Angle.normalize, type = "pred", terms = c("Club.Speed.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Launch.Angle.normalize, type = "pred", terms = c("Club.Speed.quad", "Static.Loft", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()


plot_model(lm.Launch.Angle.normalize, type = "pred", terms = c("Angle.Of.Attack.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Launch.Angle.normalize, type = "pred", terms = c("Angle.Of.Attack.quad", "Static.Loft", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()


plot_model(lm.Launch.Angle.normalize, type = "pred", terms = c("Pitch", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Launch.Angle.normalize, type = "pred", terms = c("Pitch", "Static.Loft", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()


plot_model(lm.Launch.Angle.normalize, type = "pred", terms = c("Vertical.Face.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Launch.Angle.normalize, type = "pred", terms = c("Vertical.Face.quad", "Static.Loft", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

```

## Backspin Evaluation
```{r , echo=FALSE, include = TRUE, warning=FALSE, , message = FALSE}

lm.Back.Spin.normalize <-lmer(Back.Spin.quad ~
                                # Fixed-effects
                                1 + Model:Length + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad + Club.Speed.quad +
                                # Random-effects
                                (1 + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad| Player), data = Data.Combined.train)

lm.Back.Spin.normalize <-lmer(Back.Spin.quad ~
           # Fixed-effects
           1 + Model + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad +
             + Length:Vertical.Face.quad + Static.Loft:Club.Speed.quad + Static.Loft:Vertical.Face.quad +
           # Random-effects
           (1 + Angle.Of.Attack.quad + Pitch + Vertical.Face.quad| Player), data = Data.Combined.train)

saveRDS(lm.Back.Spin.normalize, file = "mem_backs_tahoe_test.rda")


ggpredict(lm.Back.Spin.normalize)

#plot_model(lm.Back.Spin.normalize, type = "pred", terms = c("Club.Speed.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Back.Spin.normalize, type = "pred", terms = c("Angle.Of.Attack.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Back.Spin.normalize, type = "pred", terms = c("Pitch", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Back.Spin.normalize, type = "pred", terms = c("Vertical.Face.quad", "Length", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Back.Spin.normalize, type = "pred", terms = c("Club.Speed.quad", "Static.Loft", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Back.Spin.normalize, type = "pred", terms = c("Angle.Of.Attack.quad", "Static.Loft", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Back.Spin.normalize, type = "pred", terms = c("Pitch", "Static.Loft", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Back.Spin.normalize, type = "pred", terms = c("Vertical.Face.quad", "Static.Loft", "Model"), show.data = TRUE)+theme_sjplot()+theme_classic()

```

## Side Angle Evaluation
```{r , echo=FALSE, include = TRUE, warning=FALSE, , message = FALSE}

lm.Side.Angle.normalize <-lmer(Side.Angle.quad ~
           # Fixed-effects
           1 + Length*Face.To.Target.quad + Length*Lateral.Face.quad +
           # Random-effects
           (1 + Face.To.Target.quad + Lateral.Face.quad | Player), data = Data.Combined.train)

ggpredict(lm.Side.Angle.normalize)

plot_model(lm.Side.Angle.normalize, type = "pred", terms = c("Club.Speed.quad", "Length"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Side.Angle.normalize, type = "pred", terms = c("Face.To.Target.quad", "Length"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Side.Angle.normalize, type = "pred", terms = c("Lateral.Face.quad", "Length"), show.data = TRUE)+theme_sjplot()+theme_classic()

```


## Sidespin Evaluation
```{r , echo=FALSE, include = TRUE, warning=FALSE, , message = FALSE}

lm.Side.Spin.normalize <-lmer(Side.Spin.quad ~
                                # Fixed-effects
                                1 + Face.To.Path.quad + Lateral.Face.quad  +
                                # Random-effects
                                (1 + Face.To.Path.quad + Lateral.Face.quad | Player), data = Data.Combined.train)

ggpredict(lm.Side.Spin.normalize)

#plot_model(lm.Side.Spin.normalize, type = "pred", terms = c("Club.Speed.quad", "Length"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Side.Spin.normalize, type = "pred", terms = c("Face.To.Path.quad", "Length"), show.data = TRUE)+theme_sjplot()+theme_classic()

plot_model(lm.Side.Spin.normalize, type = "pred", terms = c("Lateral.Face.quad", "Length"), show.data = TRUE)+theme_sjplot()+theme_classic()

```

## Prep for building test data frame
```{r , echo=FALSE, include = TRUE, warning=FALSE, , message = FALSE}

Tahoe_length <- c(35.75, 36.0, 36.625, 37.25, 37.875, 38.5)
Tahoe_static_loft <- c(42, 37, 33, 29, 26, 23)
Tahoe_HL_length <- c(35.75, 36.0, 36.75, 37.5, 38.25, 39.0)
Tahoe_HL_static_loft <- c(43, 38, 34, 30, 27, 24)

Length.data <- data.frame(Length = c(rep(Tahoe_length, each = 8), rep(Tahoe_HL_length, each = 8)))
Static_Loft.data <- data.frame(Loft = c(rep(Tahoe_static_loft, each = 8), rep(Tahoe_HL_static_loft, each = 8)))

player_speed_dif <- (player_speed - ggpredict(lm.Club.Speed.quad, terms = "Length[37.5]")$predicted)
player_attack_dif <- (player_attack - ggpredict(lm.Angle.Of.Attack.quad, terms = "Length[37.5]")$predicted)
player_pitch_dif <- (player_pitch- ggpredict(lm.Pitch, terms = "Length[37.5]")$predicted)

#seed and norm vector
set.seed(6)#14
x <- rnorm(8, 0, 1)
Lateral.Impact.GMM <- scales::rescale(x, to = c(-15, 15), from = range(x))

mean(Lateral.Impact.GMM)

set.seed(14)
y <- rnorm(8, 0, 1)
Vertical.Impact.GMM <- scales::rescale(y, to = c(-20, 0), from = range(y))

#test <- data.frame(Lateral.Impact.GMM, Vertical.Impact.GMM)
#ggplot(test, aes(Lateral.Impact.GMM, Vertical.Impact.GMM)) + geom_point()

```

## Test data frame
```{r , echo=FALSE, include = TRUE, warning=FALSE, , message = FALSE}

new_data = c()
new_data <- data.frame(Player = rep("Population", nrow(Length.data)),
                       Model = rep(c("Tahoe Std", "Tahoe HL"), each = 48),
                       Length =c(rep(Tahoe_length, each = 8), rep(Tahoe_HL_length, each = 8)),
                       Static.Loft = c(rep(Tahoe_static_loft, each = 8), rep(Tahoe_HL_static_loft, each = 8)),
                       Club.Speed.quad = predict(lm.Club.Speed.quad, re.form= NA, newdata = Length.data) + player_speed_dif,
                       Angle.Of.Attack.quad = predict(lm.Angle.Of.Attack.quad, re.form= NA, newdata = Length.data) + player_attack_dif,
                       Face.To.Target.quad = 0,
                       Club.Path.quad = 0,
                       Face.To.Path.quad = 0,
                       Pitch = predict(lm.Pitch, re.form= NA, newdata = Length.data) + player_pitch_dif,
                       Lie.quad = rep(mean(na.omit(Data.Combined.train$Lie.quad)), 96),
                       Lateral.Face.quad = rep(Lateral.Impact.GMM, 12),
                       Vertical.Face.quad = rep(Vertical.Impact.GMM, 12))

new_data %>% group_by(Model, Length) %>% summarise(Club.Speed.quad = mean(Club.Speed.quad), Angle.Of.Attack.quad = mean(Angle.Of.Attack.quad), Pitch = mean(Pitch))

```

## predict data frame
```{r , echo=FALSE, include = TRUE, warning=FALSE, , message = FALSE}
predict_data = c()
predict_data$Model = new_data$Model
predict_data$Length = new_data$Length
predict_data$Ball.Speed <- predict(lm.Ball.Speed.normalize, re.form= NA, newdata = new_data)
predict_data$Back.Spin <- predict(lm.Back.Spin.normalize, re.form= NA, newdata = new_data)
predict_data$Launch.Angle <- predict(lm.Launch.Angle.normalize, re.form= NA, newdata = new_data)
predict_data$Side.Spin <- predict(lm.Side.Spin.normalize, re.form= NA, newdata = new_data)
predict_data$Side.Angle <- predict(lm.Side.Angle.normalize, re.form= NA, newdata = new_data)
predict_data <- data.frame(predict_data)


#Data.Combined.train %>% filter(Player == "Quenten Hooker") %>% group_by(Player, Length) %>% summarise(mean(Club.Speed.quad), mean(Pitch), mean(Angle.Of.Attack.quad))

```

## Aero code
```{r , echo=FALSE, include = FALSE, warning=FALSE}

model_col_names <- c("Model", "Club", "speed-mph", "back_spin-rpm", "launch_angle-deg", "side_spin-rpm",
                     "side_angle-deg")

colnames(predict_data) <- as.character(model_col_names)
aero_data <- predict_data %>% select("speed-mph", "back_spin-rpm", "launch_angle-deg", "side_spin-rpm",
                     "side_angle-deg")

```

```{r , echo=FALSE, include = TRUE, warning=FALSE}

library(reticulate)
#use_python("C:/Users/Quenten.hooker/AppData/Local/Programs/Python/Python39/python.exe", required=TRUE)

```


```{python, echo=FALSE, include = TRUE, warning=FALSE}

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import scipy as scipy
import downrange.downrange as downrange

#demo = downrange.Downrange()

environment = {
        'env_temp_F':  75, #[deg F]
        'env_rh-percent' : 50, #[% relative humidity]
        'env_pre-psi': 14.7, #[psi]
        'gravity' : 9.8066352, #[m/s^2], value from Petrisor's code
        'wind' : [0,0,0] #X,Y,Z - positive = downwind, __, __
        }
        
ball_properties={
        'ball_size-inch': 1.6822,
        'ball_mass-g':45.538,
        'ball_moi-ozins2': 0.0011609
        }
        
#aerosurfacepath='C:/Users/Quenten.hooker/AppData/Local/Programs/Python/Python39/Lib/site-packages/downrange/ITRdata/8323/'

demo = downrange.Downrange(
                            environment=environment,
                            ball_properties=ball_properties,
                            #aerosurfacepath=aerosurfacepath
                            )
``` 


```{python, echo=FALSE, include = FALSE, warning=FALSE, message = FALSE}

# 131.0761	5626.937	13.10392	-86.35503	-0.52511924
# 
# launch= {
#         'speed-mph':131.0761,
#         'back_spin-rpm' : 5626.937,
#         'launch_angle-deg' : 13.10392,
#         'side_spin-rpm' : -86.35503,
#         'side_angle-deg' : -0.52511924} 
#         
#     results = demo.predictdownrange(launch)
#     
#     
#     results[1]

#From model predictions
py_aero_predict = r.aero_data

test = []
for k, row in py_aero_predict.iterrows():
  results = demo.predictdownrange(row)
  test.append(results)

trajectory, results = zip(*test)

df = pd.DataFrame(results)
df2 = pd.DataFrame(trajectory)
#df2 = pd.DataFrame(trajectory[1])
#df3 = pd.DataFrame(trajectory[31])
#df4 = pd.DataFrame(trajectory[61])

```

```{r , echo=FALSE, include = TRUE, warning=FALSE}

df_1 <- data.frame(reticulate::py$df)
#df_2 <- data.frame(reticulate::py$df2)

predict_data$Carry.aero <- df_1$carry_yd
predict_data$Offline.aero <- df_1$carryDisp_yd

#predict_data <- predict_data %>% group_by(Club) %>% mutate(obs = n()) %>% filter(obs > 5)
model_col_names <- c("Model", "Length", "Ball.Speed", "Back.Spin", "Launch.Angle", "Side.Spin", "Side.Angle", "Carry.aero", "Offline.aero")
colnames(predict_data) <- model_col_names
predict_data$Model <- rep(c("Tahoe", "Tahoe HL"), each = 48)
predict_data

```


```{r , echo=FALSE, include = TRUE, warning=FALSE}

predict_data$Club[predict_data$Model == "Tahoe" & predict_data$Length== 35.75] <- "PW"
predict_data$Club[predict_data$Model == "Tahoe" & predict_data$Length== 36.00] <- "9"
predict_data$Club[predict_data$Model == "Tahoe" & predict_data$Length== 36.625] <- "8"
predict_data$Club[predict_data$Model == "Tahoe" & predict_data$Length== 37.25] <- "7"
predict_data$Club[predict_data$Model == "Tahoe" & predict_data$Length== 37.875] <- "6"
predict_data$Club[predict_data$Model == "Tahoe" & predict_data$Length== 38.50] <- "5"
#predict_data$Club[predict_data$Club == "Tahoe" & predict_data$Length== 39.125] <- "4"

predict_data$Club[predict_data$Model == "Tahoe HL" & predict_data$Length== 35.75] <- "PW"
predict_data$Club[predict_data$Model == "Tahoe HL" & predict_data$Length== 36.00] <- "9"
predict_data$Club[predict_data$Model == "Tahoe HL" & predict_data$Length== 36.75] <- "8"
predict_data$Club[predict_data$Model == "Tahoe HL" & predict_data$Length== 37.50] <- "7"
predict_data$Club[predict_data$Model == "Tahoe HL" & predict_data$Length== 38.25] <- "6"
predict_data$Club[predict_data$Model == "Tahoe HL" & predict_data$Length== 39.00] <- "5"
#predict_data$Club[predict_data$Club == "Tahoe HL" & predict_data$Length== 39.750] <- "4"

predict_data <- within(predict_data, {
  Club <- factor(Club)
  Length <- factor(Length)
  Model <- factor(Model)
  })

```



Downrange Plots
---------------------------------------------------------------------------------------------------
```{r , echo=FALSE, include = TRUE, warning=FALSE}

predict_data_plot <- predict_data

predict_data_plot %>% group_by(Length, Model) %>% summarise(Carry.aero.avg = mean(Carry.aero), Carry.aero.sd = sd(Carry.aero))

predict_data_plot %>% group_by(Model, Length) %>% summarise(Ball.Speed = mean(Ball.Speed), Back.Spin = mean(Back.Spin), Launch.Angle = mean(Launch.Angle), Side.Spin = mean(Side.Spin), Side.Angle = mean(Side.Angle))

annotate_npc <- function(label, x, y, ...)
{
  ggplot2::annotation_custom(grid::textGrob(
    x = unit(x, "npc"), y = unit(y, "npc"), label = label, ...))
}

ggplot(predict_data_plot,  aes(x = Offline.aero, y = Carry.aero, color = Model, shape = Club)) + geom_point() + stat_ellipse(aes(color = Model, shape = Club), level = 0.85, type = "t")+ theme_classic(base_size = 18)+theme(legend.position = "right") + coord_cartesian(xlim = c(plyr::round_any(min(predict_data$Offline.aero)-0, 5, f = floor), plyr::round_any(max(predict_data$Offline.aero)+0, 5, f = ceiling)), ylim = c(plyr::round_any(min(predict_data$Carry.aero)-5, 10, f = floor), plyr::round_any(max(predict_data$Carry.aero)+10, 10, f = ceiling))) + ylab("Carry.predict (yds)") + xlab("Offline.predict (yds)")

```

```{r , echo=FALSE, include = TRUE, warning=FALSE}

trajectory <- predict_data %>% group_by(Model, Club) %>% summarise(Ball.Speed = mean(Ball.Speed), Back.Spin = mean(Back.Spin), Launch.Angle = mean(Launch.Angle), Side.Spin = mean(Side.Spin), Side.Angle = mean(Side.Angle), Carry.aero = mean(Carry.aero))

trajectory

#summary(Launch.Angle.Normalize)
```

```{r , echo=FALSE, include = FALSE, warning=FALSE}

model_col_names <- c("Model", "Club", "speed-mph", "back_spin-rpm", "launch_angle-deg", "side_spin-rpm",
                     "side_angle-deg")

colnames(trajectory) <- as.character(model_col_names)
aero_data <- trajectory %>% select("speed-mph", "back_spin-rpm", "launch_angle-deg", "side_spin-rpm",
                     "side_angle-deg")

```


```{python, echo=FALSE, include = FALSE, warning=FALSE, message = FALSE}

# 131.0761	5626.937	13.10392	-86.35503	-0.52511924
# 
# launch= {
#         'speed-mph':131.0761,
#         'back_spin-rpm' : 5626.937,
#         'launch_angle-deg' : 13.10392,
#         'side_spin-rpm' : -86.35503,
#         'side_angle-deg' : -0.52511924} 
#         
#     results = demo.predictdownrange(launch)
#     
#     
#     results[1]

#From model predictions
py_aero_predict = r.aero_data

test = []
for k, row in py_aero_predict.iterrows():
  results = demo.predictdownrange(row)
  test.append(results)

trajectory, results = zip(*test)

df = pd.DataFrame(results)
df2 = pd.DataFrame(trajectory)

trajectory_0 = trajectory[0]
trajectory_1 = trajectory[1]
trajectory_2 = trajectory[2]
trajectory_3 = trajectory[3]
trajectory_4 = trajectory[4]
trajectory_5 = trajectory[5]
trajectory_6 = trajectory[6]
trajectory_7 = trajectory[7]
trajectory_8 = trajectory[8]
trajectory_9 = trajectory[9]
trajectory_10 = trajectory[10]
trajectory_11 = trajectory[11]
```



```{r , echo=FALSE, include = TRUE, warning=FALSE}

#Create dataframe of trajectory by ball
df_0 <- cbind(levels(trajectory$Model)[1], levels(trajectory$Club)[1], data.frame(reticulate::py$trajectory_0))
colnames(df_0) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_1 <- cbind(levels(trajectory$Model)[1], levels(trajectory$Club)[2], data.frame(reticulate::py$trajectory_1))
colnames(df_1) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_2 <- cbind(levels(trajectory$Model)[1], levels(trajectory$Club)[3], data.frame(reticulate::py$trajectory_2))
colnames(df_2) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_3 <- cbind(levels(trajectory$Model)[1], levels(trajectory$Club)[4], data.frame(reticulate::py$trajectory_3))
colnames(df_3) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_4 <- cbind(levels(trajectory$Model)[1], levels(trajectory$Club)[5], data.frame(reticulate::py$trajectory_4))
colnames(df_4) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time")
df_5 <- cbind(levels(trajectory$Model)[1], levels(trajectory$Club)[6], data.frame(reticulate::py$trajectory_5))
colnames(df_5) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_0b <- cbind(levels(trajectory$Model)[2], levels(trajectory$Club)[1], data.frame(reticulate::py$trajectory_6))
colnames(df_0b) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_1b <- cbind(levels(trajectory$Model)[2], levels(trajectory$Club)[2], data.frame(reticulate::py$trajectory_7))
colnames(df_1b) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_2b <- cbind(levels(trajectory$Model)[2], levels(trajectory$Club)[3], data.frame(reticulate::py$trajectory_8))
colnames(df_2b) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_3b <- cbind(levels(trajectory$Model)[2], levels(trajectory$Club)[4], data.frame(reticulate::py$trajectory_9))
colnames(df_3b) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 
df_4b <- cbind(levels(trajectory$Model)[2], levels(trajectory$Club)[5], data.frame(reticulate::py$trajectory_10))
colnames(df_4b) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time")
df_5b <- cbind(levels(trajectory$Model)[2], levels(trajectory$Club)[6], data.frame(reticulate::py$trajectory_11))
colnames(df_5b) <- c("Model", "Club", "X.yards", "Y.yards", "Z.yards", "Time") 

predict_trajectory <- rbind(df_0, df_1, df_2, df_3, df_4, df_5, df_0b, df_1b, df_2b, df_3b, df_4b, df_5b)

#Correct variable type
predict_trajectory <- within(predict_trajectory, {
  Club <- factor(Club)
  MOdel <- factor(Club)
  })

ggplot(predict_trajectory, aes(x = X.yards, y = Z.yards*3, color = Model, shape = Club)) +
  geom_point() + xlab("Distance (yards)") + ylab("Height (ft)") + theme_classic()

```


# Sim test for distance from opening for randy
```{r , echo=FALSE, include = TRUE, warning=FALSE}
#use_python("C:/Users/Quenten.hooker/AppData/Local/Programs/Python/Python39/python.exe", required=TRUE)
source_python('python_ref.py')


predict_data = c()
# predict_data <- data.frame(Ball.Speed = rep(c(82), each = 3),
#                            Launch.Angle = rep(c(33, 39, 45), 1),
#                            Back.spin = rep(c(12800), 3),
#                            Side.Angle = rep(c(0), 3),
#                            Side.Spin = rep(c(0), 3))

predict_data <- data.frame(Ball.Speed = c(175, 174.4, 173.8),
                           Launch.Angle = c(9.6, 10.33, 11.06),
                           Back.spin = c(2798, 2930, 3062),
                           Side.Angle = rep(c(0), 3),
                           Side.Spin = rep(c(0), 3))


model_col_names <- c("Ballspeed", "LaunchAngle", "Backspin", "SideAngle", "SideSpin")
colnames(predict_data) <- model_col_names
aero_data <- aerotest(predict_data)


downrange_data <- aero_data %>% select(carrydisp, carrydist)


traj_Z_data <- aero_data[["Z yards"]]
traj_Z_data <- as.data.frame(do.call(cbind, traj_Z_data))
traj_Z_data <- pivot_longer(traj_Z_data, cols=everything()) %>% arrange(name)

traj_X_data <- aero_data[["X yards"]]
traj_X_data <- as.data.frame(do.call(cbind, traj_X_data))
traj_X_data <- pivot_longer(traj_X_data, cols=everything()) %>% arrange(name)

traj_Y_data <- aero_data[["Y yards"]]
traj_Y_data <- as.data.frame(do.call(cbind, traj_Y_data))
traj_Y_data <- pivot_longer(traj_Y_data, cols=everything()) %>% arrange(name)

Traj <- data.frame(name = traj_X_data$name,
                   X.yards = traj_X_data$value,
                   Y.yards = traj_Y_data$value,
                   Z.yards = traj_Z_data$value)


Traj$name[Traj$name== "V1"] <- "BS= 82, LA= 33, backs= 12800"
Traj$name[Traj$name== "V2"] <- "BS= 82, LA= 39, backs= 12800"
Traj$name[Traj$name== "V3"] <- "BS= 82, LA= 45, backs= 12800"

axx <- list(
    title = "Distance (ft)"
)

axy <- list(
  range = c(-10,10),
  title = "Offline (ft)"
)

axz <- list(
  title = "Height (ft)"
)

fig <- plot_ly(Traj, x = ~X.yards*3, y = ~Y.yards*3, z = ~Z.yards*3, color = ~name, type = 'scatter3d', mode = 'lines', colors = c("red", "black", "blue")) %>%
      layout(scene = list(xaxis=axx,yaxis=axy,zaxis=axz))
    
#fig <- fig %>% add_lines(y = 0, x = c(0,100), line = list(color = "grey", width = 2), inherit = FALSE, showlegend = FALSE)
fig    


htmlwidgets::saveWidget(
                widget = fig, #the plotly object
                file = "ECPC_Lab_Wedge_Sim.html", #the path & file name
                selfcontained = TRUE #creates a single html file
                )

```


## Advanced model building



#### standard 80-20 train test evaluation, Ball Speed through set
```{r , echo=FALSE, include = TRUE, warning=FALSE}

sample.split(Data.Combined$Ball.Speed.quad, SplitRatio = 0.80)->split_index
train  <- subset(Data.Combined,split_index==T)
test <- subset(Data.Combined,split_index==F)


train <- within(train, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})

test <- within(test, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})


mod_regress <-lmer(Ball.Speed.quad ~
           # Fixed-effects
           1 + Length + I(Length^2) + Static.Loft + I(Static.Loft^2) + Model + Carry.quad +
           # Random-effects
           (1 + Length + I(Length^2) + Static.Loft + I(Static.Loft^2) + Carry.quad | Player), data = train)

#ggpredict(mod_regress)

predict(mod_regress,test)->result_regress


cbind(Actual=test$Ball.Speed.quad,Predicted=result_regress)->Final_Data
as.data.frame(Final_Data)->Final_Data

(Final_Data$Actual- Final_Data$Predicted)->error
cbind(Final_Data,error)->Final_Data

Final_Data <- Final_Data %>% na.omit()

rmse1<-sqrt(mean(Final_Data$error^2))
rmse1

ggplot(Final_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm")

#ggplot(Data.Combined, aes(x = Length, y = Ball.Speed.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7))

```

   
#### standard 80-20 train test evaluation, Launch Angle through set
```{r , echo=FALSE, include = TRUE, warning=FALSE}

sample.split(Data.Combined$Launch.Angle.quad, SplitRatio = 0.80)->split_index
train  <- subset(Data.Combined,split_index==T)
test <- subset(Data.Combined,split_index==F)


train <- within(train, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})

test <- within(test, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})


mod_regress <-lmer(Launch.Angle.quad ~
           # Fixed-effects
           1 + Length + I(Length^2) + Static.Loft + I(Static.Loft^2) + Model + Carry.quad +
           # Random-effects
           (1 + Length + I(Length^2) + Static.Loft + I(Static.Loft^2) + Carry.quad | Player), data = train)

#ggpredict(mod_regress)

predict(mod_regress,test)->result_regress


cbind(Actual=test$Launch.Angle.quad,Predicted=result_regress)->Final_Data
as.data.frame(Final_Data)->Final_Data

(Final_Data$Actual- Final_Data$Predicted)->error
cbind(Final_Data,error)->Final_Data

Final_Data <- Final_Data %>% na.omit()

rmse1<-sqrt(mean(Final_Data$error^2))
rmse1

ggplot(Final_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm")

#ggplot(Data.Combined, aes(x = Length, y = Ball.Speed.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7))

```   
   
   
#### standard 80-20 train test evaluation, Backspin through set
```{r , echo=FALSE, include = TRUE, warning=FALSE}

sample.split(Data.Combined$Back.Spin.quad, SplitRatio = 0.80)->split_index
train  <- subset(Data.Combined,split_index==T)
test <- subset(Data.Combined,split_index==F)


train <- within(train, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})

test <- within(test, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})


mod_regress <-lmer(Back.Spin.quad ~
           # Fixed-effects
           1 + Length + I(Length^2) + Static.Loft + I(Static.Loft^2) + Model +
           # Random-effects
           (1 + Length + I(Length^2) + Static.Loft + I(Static.Loft^2) | Player), data = train)

ggpredict(mod_regress)

predict(mod_regress,test)->result_regress


cbind(Actual=test$Back.Spin.quad,Predicted=result_regress)->Final_Data
as.data.frame(Final_Data)->Final_Data

(Final_Data$Actual- Final_Data$Predicted)->error
cbind(Final_Data,error)->Final_Data

Final_Data <- Final_Data %>% na.omit()

rmse1<-sqrt(mean(Final_Data$error^2))
rmse1

ggplot(Final_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm")

#ggplot(Data.Combined, aes(x = Length, y = Ball.Speed.quad)) + geom_point(aes(color = Player)) + geom_smooth(aes(color = Player), method = "lm", formula = y ~ x + I(x^2), se=TRUE, level = .8, linetype = 1)+ theme_classic() + theme(legend.key.size = unit(.5, 'cm'), legend.key.width= unit(.1, 'cm'), legend.text = element_text(size=7))

```   
           
#### standard 80-20 train test evaluation, club head speed
```{r , echo=FALSE, include = TRUE, warning=FALSE}

Data.Combined.7I <- Data.Combined %>% filter(Club == "7 Iron")

Data.Combined.7I <- Data.Combined.7I %>% filter(Club.Speed.quad < 150, Club.Speed.quad > 50) 

sample.split(Data.Combined.7I$Club.Speed.quad,SplitRatio = 0.80)->split_index
train  <- subset(Data.Combined.7I,split_index==T)
test <- subset(Data.Combined.7I,split_index==F)


train <- within(train, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})

test <- within(test, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})


# mod_regress <-lmer(Club.Speed.quad ~
#            # Fixed-effects
#            1 + Ball.Speed.quad*Launch.Angle.quad*Side.Angle.quad*Side.Spin.quad*Back.Spin.quad*Tags +
#            # Random-effects
#            (1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad| Player), data = train)

mod_regress <-lmer(Club.Speed.quad ~
           # Fixed-effects
           1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad + Tags +
           # Random-effects
           (1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad | Player), data = train)

ggpredict(mod_regress)

predict(mod_regress,test)->result_regress


cbind(Actual=test$Club.Speed.quad,Predicted=result_regress)->Final_Data
as.data.frame(Final_Data)->Final_Data

(Final_Data$Actual- Final_Data$Predicted)->error
cbind(Final_Data,error)->Final_Data

Final_Data <- Final_Data %>% na.omit()

rmse1<-sqrt(mean(Final_Data$error^2))
rmse1

ggplot(Final_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm")

```


#### standard 80-20 train test evaluation, attack
```{r , echo=FALSE, include = TRUE, warning=FALSE}

Data.Combined.7I <- Data.Combined %>% filter(Club == "7 Iron")

Data.Combined.7I <- Data.Combined.7I 

sample.split(Data.Combined.7I$Angle.Of.Attack.quad,SplitRatio = 0.80)->split_index
train  <- subset(Data.Combined.7I,split_index==T)
test <- subset(Data.Combined.7I,split_index==F)


train <- within(train, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})

test <- within(test, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})


# mod_regress <-lmer(Club.Speed.quad ~
#            # Fixed-effects
#            1 + Ball.Speed.quad*Launch.Angle.quad*Side.Angle.quad*Side.Spin.quad*Back.Spin.quad*Tags +
#            # Random-effects
#            (1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad| Player), data = train)

mod_regress <-lmer(Angle.Of.Attack.quad ~
           # Fixed-effects
           1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad + Lateral.Face.quad +
             Vertical.Face.quad + Tags +
           # Random-effects
           (1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad | Player), data = train)


predict(mod_regress,test)->result_regress


cbind(Actual=test$Angle.Of.Attack.quad,Predicted=result_regress)->Final_Data
as.data.frame(Final_Data)->Final_Data

(Final_Data$Actual- Final_Data$Predicted)->error
cbind(Final_Data,error)->Final_Data

Final_Data <- Final_Data %>% na.omit()

rmse1<-sqrt(mean(Final_Data$error^2))
rmse1

ggplot(Final_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm")

```

#### standard 80-20 train test evaluation, loft
```{r , echo=FALSE, include = TRUE, warning=FALSE}

Data.Combined.7I <- Data.Combined %>% filter(Club == "7 Iron")

Data.Combined.7I <- Data.Combined.7I 

sample.split(Data.Combined.7I$Loft.quad,SplitRatio = 0.80)->split_index
train  <- subset(Data.Combined.7I,split_index==T)
test <- subset(Data.Combined.7I,split_index==F)


train <- within(train, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})

test <- within(test, {
  Player <- factor(as.character(Player))
  Tags <- factor(as.character(Tags))})


# mod_regress <-lmer(Club.Speed.quad ~
#            # Fixed-effects
#            1 + Ball.Speed.quad*Launch.Angle.quad*Side.Angle.quad*Side.Spin.quad*Back.Spin.quad*Tags +
#            # Random-effects
#            (1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad| Player), data = train)

mod_regress <-lmer(Pitch ~
           # Fixed-effects
           1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad + Lateral.Face.quad +
             Vertical.Face.quad + Tags + 
           # Random-effects
           (1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad | Player), data = train)

ggpredict(mod_regress)


predict(mod_regress,test)->result_regress


cbind(Actual=test$Loft.quad,Predicted=result_regress)->Final_Data
as.data.frame(Final_Data)->Final_Data

(Final_Data$Actual- Final_Data$Predicted)->error
cbind(Final_Data,error)->Final_Data

Final_Data <- Final_Data %>% na.omit()

rmse1<-sqrt(mean(Final_Data$error^2))
rmse1

ggplot(Final_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm")

```  
  
  
```{r , echo=FALSE, include = TRUE, warning=FALSE}

Data.Combined.7I <- Data.Combined %>% filter(Club == "7 Iron")


lm.Club.Speed <-lmer(Club.Speed.quad ~
           # Fixed-effects
           1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad +  Tags +
           # Random-effects
           (1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad| Player), data = Data.Combined.7I)


# lm.Club.Speed <-lmer(Club.Speed.quad ~
#            # Fixed-effects
#            1 + Ball.Speed.quad*Launch.Angle.quad*Side.Angle.quad*Side.Spin.quad*Back.Spin.quad*Tags +
#            # Random-effects
#            (1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad| Player), data = Data.Combined.7I)

# summary(lm.Club.Speed)
# 
# ggpredict(lm.Club.Speed)
```

## Person prediction testing - Me
```{r , echo=FALSE, include = TRUE, warning=FALSE}

new_data <- data.frame(Ball.Speed.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Ball.Speed.quad)),
                       Launch.Angle.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Launch.Angle.quad)),
                       Side.Angle.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Side.Angle.quad)),
                       Back.Spin.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Back.Spin.quad)),
                       Side.Spin.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Side.Spin.quad)),
                       Tags = rep(c("MB21"), each = 1),
                       Player = rep("Quenten Hooker", each = 1))

#summary(lm.Club.Speed)

colnames(new_data) <- c("Ball.Speed.quad", "Launch.Angle.quad", "Side.Angle.quad", "Back.Spin.quad", "Side.Spin.quad", "Tags", "Player")

predict(lm.Club.Speed, re.form= ~(1 + Ball.Speed.quad + Launch.Angle.quad + Side.Angle.quad + Side.Spin.quad + Back.Spin.quad| Player), newdata = new_data)
Data.Combined.7I %>% filter(Player == "Quenten Hooker", Tags == "MB21") %>% summarise(Club.Speed.quad = mean(Club.Speed.quad))
```


## Random simulations generating testing
```{r , echo=FALSE, include = TRUE, warning=FALSE}

new_data <- data.frame(Ball.Speed.quad = runif(100, min=110, max=130),
                       Launch.Angle.quad = runif(100, min=15.5, max=17),
                       Side.Angle.quad = runif(100, min=0, max=0),
                       Back.Spin.quad = runif(100, min=6000, max=8000),
                       Side.Spin.quad = runif(100, min=0, max=0),
                       Tags = rep(c("Tahoe Std"), each = 100),
                       Player = rep("Population", each = 100))

predict <- data.frame(Club.Speed.quad = predict(lm.Club.Speed, re.form= NA, newdata = new_data))


ggplot(predict, aes(x = Club.Speed.quad)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()

```

# Engage
## Load Packages
```{r , echo=TRUE, include = FALSE}

library('odbc')
library('DBI')
library('dplyr')
library('stringr')


```


## Establish Connection
```{r, echo=FALSE, include = TRUE}

con <- DBI::dbConnect(odbc::odbc(),
                       Driver = "SQL Server",
                       Server = 'icgEngagedb.corp.callawaygolf.com',
                       Database = "Engage",                    
                       Trusted_Connection = "yes")

#dbListTables(con)
```

## Example SQL to grab data
```{r, echo=FALSE, include = TRUE}

Data.Engage <- DBI::dbGetQuery(con,
                              "SELECT Date, ShotId, FittingId, AccountFullName, Location, EventName, BallFamilyName, CategoryId, CategoryName, ClubFamilyId,
                              ClubFamilyName, MonitorTypeName, ImpactHeadSpeedMph, ImpactAttackAngleDeg, ImpactPathAngleDeg,
                              ImpactYawAngleDeg, ImpactPitchAngleDeg, ImpactRollAngleDeg, ImpactHorizLocInch, ImpactVertLocInch,
                              BallSpeedMph, BallLaunchAngleDeg, BallSideAngleDeg, BallBackSpinRpm, BallSideSpinRpm, ShotApexFt,
                              ShotMaxLateralTravelFt, ShotCarryYd, ShotCarryDispFt, ShotTotalYd, ShotTotalDispFt,
                              ShotFlightTimeSec, SmashFactor
                              FROM Engage.cg_Engage.vwMeasuredShotsAll;")

Data.Engage %>% group_by(MonitorTypeName) %>% summarise(n())
Data.Engage %>% group_by(Location) %>% summarise(n())

Data.Engage %>% 

Data.Engage %>% filter(EventName == 'Callaway Performance Center - Carlsbad') %>% group_by(AccountFullName) %>% summarise(n())

Data_Engage_Quad_Carlsbad <- Data.Engage %>% filter(EventName == 'Callaway Performance Center - Carlsbad')

Data_Engage_Quad_Carlsbad %>% group_by(FittingId) %>% summarise(num = n()) %>% arrange(desc(num))

Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons") %>% group_by(ClubFamilyName) %>% summarise(num = n()) %>% arrange(desc(num))


Data.Engage %>% filter(MonitorTypeName == "FS_Quad" | MonitorTypeName == "CPAS" | MonitorTypeName == "Foresight GC2") %>% filter(CategoryName == "Woods") %>% filter(str_detect(ClubFamilyName, fixed(c("driver"), ignore_case=TRUE))) %>% group_by(Location) %>% summarise(n())

Data.sum <- Data.Engage %>% filter(MonitorTypeName == "FS_Quad" | MonitorTypeName == "CPAS" | MonitorTypeName == "Foresight GC2") %>% filter(CategoryName == "Woods") %>% filter(str_detect(ClubFamilyName, fixed(c("driver"), ignore_case=TRUE))) %>% group_by(FittingId) %>% summarise(obs = n(), Mean.Head.Speed = mean(na.omit(ImpactHeadSpeedMph)))

quantile(na.omit(Data.sum$Mean.Head.Speed), probs = .90)


my_binwidth <- 50

ggplot(Data.sum %>% filter(Mean.Head.Speed > 20, Mean.Head.Speed < 140), aes(x = Mean.Head.Speed)) + geom_histogram(color = "black", fill = "grey", bins = 50) + geom_density(aes(y = ..density.. * 40000), color = "red", adjust = 2) + scale_x_continuous(limits = c(0, 150)) + xlab("Player Average Head Speed (mph)") + ylab("Player Count (n)")+ geom_vline(xintercept=quantile(na.omit(Data.sum$Mean.Head.Speed), probs = .90), color = "blue") + annotate("text", label = "90th percentile = 106.3mph", x = 30, y = 1200, size = unit(5, "pt"))

```

#### MEM and RF, club head speed
```{r , echo=FALSE, include = TRUE, warning=FALSE}

#select correct clubs
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons", ClubFamilyName == "APEX TCB 21" | ClubFamilyName == "APEX 21" | ClubFamilyName == "APEX DCB 21" | ClubFamilyName == "APEX PRO 21 IRONS" | ClubFamilyName == "APEX MB 21" | ClubFamilyName == "PARADYM IRONS" | ClubFamilyName == "PARADYM X IRONS")

#rename clubs
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX TCB 21" ] <- "APEX_TCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX 21" ] <- "APEX_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX DCB 21" ] <- "APEX_DCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX PRO 21 IRONS" ] <- "APEX_PRO_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX MB 21" ] <- "APEX_MB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "PARADYM IRONS" ] <- "PARADYM_23"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "PARADYM X IRONS" ] <- "PARADYM_X_23"



Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(!is.na(ClubFamilyName), !is.na(ImpactHeadSpeedMph)) 

obs <- Data_Engage_Quad_Carlsbad_Iron_Select %>% group_by(FittingId) %>% summarise(num = n()) 
Data_Engage_Quad_Carlsbad_Iron_Select <- merge(Data_Engage_Quad_Carlsbad_Iron_Select, obs, by.x = c("FittingId"), by.y = c("FittingId")) 
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(num > 7) 


Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(SmashFactor > 1, SmashFactor < 1.4, ImpactHeadSpeedMph < 110, ImpactHeadSpeedMph > 50, BallLaunchAngleDeg > 5, BallLaunchAngleDeg < 30, BallSideAngleDeg < 10, BallSideAngleDeg > -10, BallBackSpinRpm > 1000, BallBackSpinRpm < 9000, BallSideSpinRpm < 3000, BallSideSpinRpm > -3000)

#apply(Data_Engage_Quad_Carlsbad_Iron_Select,2,function(x) sum(is.na(x)))


sample.split(Data_Engage_Quad_Carlsbad_Iron_Select$ImpactHeadSpeedMph,SplitRatio = 0.80)->split_index
train  <- subset(Data_Engage_Quad_Carlsbad_Iron_Select,split_index==T)
test <- subset(Data_Engage_Quad_Carlsbad_Iron_Select,split_index==F)


Q_test_data <- data.frame(Ball.Speed.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Ball.Speed.quad)),
                       Launch.Angle.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Launch.Angle.quad)),
                       Side.Angle.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Side.Angle.quad)),
                       Back.Spin.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Back.Spin.quad)),
                       Side.Spin.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Side.Spin.quad)),
                       Tags = rep(c("APEX_MB_21"), each = 1),
                       Player = rep("Quenten Hooker", each = 1))

colnames(Q_test_data) <- c("BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg", "BallBackSpinRpm", "BallSideSpinRpm", "ClubFamilyName", "FittingId")

train <- within(train, {
  FittingId <- factor(as.character(FittingId))
  ClubFamilyName <- factor(as.character(ClubFamilyName))})

test <- within(test, {
  FittingId <- factor(as.character(FittingId))
  ClubFamilyName <- factor(as.character(ClubFamilyName))})

Q_test_data <- within(Q_test_data, {
  FittingId <- factor(as.character(FittingId))
  ClubFamilyName <- factor(as.character(ClubFamilyName))})


# mod_regress <-lmer(ImpactHeadSpeedMph ~
#            # Fixed-effects
#            1 + BallSpeedMph*BallLaunchAngleDeg*BallSideAngleDeg*BallBackSpinRpm*BallSideSpinRpm*ClubFamilyName +
#            # Random-effects
#            (1 + BallSpeedMph + BallLaunchAngleDeg + BallSideAngleDeg + BallBackSpinRpm + BallSideSpinRpm | FittingId), data = train)

mod_regress <-lmer(ImpactHeadSpeedMph ~
           # Fixed-effects
           1 + BallSpeedMph + BallLaunchAngleDeg + BallSideAngleDeg + BallBackSpinRpm + BallSideSpinRpm + ClubFamilyName +
           # Random-effects
           (1 + BallSpeedMph + BallLaunchAngleDeg + BallSideAngleDeg + BallBackSpinRpm + BallSideSpinRpm | FittingId), data = train)

#saveRDS(mod_regress, file = "rf.rda")
mod_regress <- readRDS(file = "mem.rda")

# mod_regress <- randomForest(ImpactHeadSpeedMph  ~
#                               BallSpeedMph + BallLaunchAngleDeg + BallSideAngleDeg + BallBackSpinRpm + BallSideSpinRpm + ClubFamilyName,
#                             data = train, ntree=1000, importance=TRUE)

#ggpredict(mod_regress)

#unique(as.numeric(row.names(ranef(mod_regress)$FittingId)))

result_regress <- predict(mod_regress,test, allow.new.levels = TRUE)
#result_regress
predict(mod_regress,Q_test_data, allow.new.levels = TRUE)
Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Club.Speed.quad))

Final_Data <- cbind(Actual=test$ImpactHeadSpeedMph,Predicted=result_regress)
Final_Data <- as.data.frame(Final_Data)

error <- (Final_Data$Actual- Final_Data$Predicted)
Final_Data <- cbind(Final_Data,error)

Final_Data <- Final_Data %>% na.omit()

rmse1<-sqrt(mean(Final_Data$error^2))
rmse1

MSE.mem <- sum((Final_Data$error)^2)/nrow(test)
MSE.mem

ggplot(Final_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm")+ annotate(geom="text", x=60, y=110, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=60, y=105, label= paste("RMSE = ", round(rmse1, 2)))


```

# NN for our inverse prediction problem using neuralnet package
```{r , echo=FALSE, include = TRUE, warning=FALSE}

#library('tidyverse')
library('neuralnet')

Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons", ClubFamilyName == "APEX TCB 21" | ClubFamilyName == "APEX 21" | ClubFamilyName == "APEX DCB 21" | ClubFamilyName == "APEX PRO 21 IRONS" | ClubFamilyName == "APEX MB 21")

Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX TCB 21" ] <- "APEX_TCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX 21" ] <- "APEX_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX DCB 21" ] <- "APEX_DCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX PRO 21 IRONS" ] <- "APEX_PRO_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX MB 21" ] <- "APEX_MB_21"

Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(!is.na(ClubFamilyName), !is.na(ImpactHeadSpeedMph)) 

Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(SmashFactor > 1, SmashFactor < 1.4, ImpactHeadSpeedMph < 110, ImpactHeadSpeedMph > 50)#, BallLaunchAngleDeg > 5, BallLaunchAngleDeg < 30, BallSideAngleDeg < 10, BallSideAngleDeg > -10, BallBackSpinRpm > 1000, BallBackSpinRpm < 9000, BallSideSpinRpm < 3000, BallSideSpinRpm > -3000)

data <- Data_Engage_Quad_Carlsbad_Iron_Select %>% select(ClubFamilyName, ImpactHeadSpeedMph, BallSpeedMph, BallLaunchAngleDeg, BallSideAngleDeg, BallBackSpinRpm, BallSideSpinRpm)

data <- unique(data)

#summary(data)

data <- data %>% mutate(value = 1)  %>% spread(ClubFamilyName, value,  fill = 0)

#check for NAs
apply(data,2,function(x) sum(is.na(x)))

index <- sample(1:nrow(data),round(0.75*nrow(data)))
train <- data[index,]
test <- data[-index,]
lm.fit <- glm(ImpactHeadSpeedMph~., data=train)
summary(lm.fit)
pr.lm <- predict(lm.fit,test)
MSE.lm <- sum((pr.lm - test$ImpactHeadSpeedMph)^2)/nrow(test)
rmse.lm <- sqrt(mean((pr.lm - test$ImpactHeadSpeedMph)^2))

maxs <- apply(data, 2, max) 
mins <- apply(data, 2, min)
scaled <- as.data.frame(scale(data, center = mins, scale = maxs - mins))
train_ <- scaled[index,]
test_ <- scaled[-index,]

n <- names(train_)

lhsOfFormula <- "ImpactHeadSpeedMph"
rhsOfFormula  <- paste(n[!n %in% "ImpactHeadSpeedMph"])
ns <- sapply(c(lhsOfFormula, rhsOfFormula), as.name)
f <- formula(paste(ns[1], paste(ns[-1], collapse="+"), sep=" ~ "))

#nn <- neuralnet(f,data=train_,hidden=c(5,3),linear.output=T)


nn <- neuralnet(formula = f, data = train_, hidden = 5, threshold = 0.01,
  stepmax = 1e+06, rep = 1, startweights = NULL,
  #learningrate.limit = NULL,
  #learningrate.factor = list(minus = 0.5,  plus = 1.2),
  learningrate = NULL, lifesign = "minimal",
  lifesign.step = 1000, algorithm = "rprop+", err.fct = "sse",
  act.fct = "logistic", linear.output = TRUE, exclude = NULL,
  constant.weights = NULL, likelihood = FALSE)

#saveRDS(nn, file = "nn_5_test.rda")
class(nn)

plot(nn)

pr.nn <- compute(nn,test_[,1:11])
pr.nn_ <- pr.nn$net.result*(max(data$ImpactHeadSpeedMph)-min(data$ImpactHeadSpeedMph))+min(data$ImpactHeadSpeedMph)
test.r <- (test_$ImpactHeadSpeedMph)*(max(data$ImpactHeadSpeedMph)-min(data$ImpactHeadSpeedMph))+min(data$ImpactHeadSpeedMph)
MSE.nn <- sum((test.r - pr.nn_)^2)/nrow(test_)
rmse.nn <- sqrt(mean((test.r - pr.nn_)^2))


print(paste(MSE.lm,MSE.nn))
print(paste(rmse.lm,rmse.nn))


par(mfrow=c(1,2))
plot(test$ImpactHeadSpeedMph,pr.nn_,col='red',main='Real vs predicted NN',pch=18,cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend='NN',pch=18,col='red', bty='n')
plot(test$ImpactHeadSpeedMph,pr.lm,col='blue',main='Real vs predicted lm',pch=18, cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend='LM',pch=18,col='blue', bty='n', cex=.95)

plot(test$ImpactHeadSpeedMph,pr.nn_,col='red',main='Real vs predicted NN',pch=18,cex=0.7)
points(test$ImpactHeadSpeedMph,pr.lm,col='blue',pch=18,cex=0.7)
abline(0,1,lwd=2)
legend('bottomright',legend=c('NN','LM'),pch=18,col=c('red','blue'))


```


# NN for our inverse prediction problem using neuralnet package
```{r , echo=FALSE, include = TRUE, warning = TRUE}

#library(quantmod) 
#library(nnet)
library('doMC')
library('tensorflow')
library('caret')
library('NeuralNetTools')

set.seed(12345)

#select correct clubs
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons", ClubFamilyName == "APEX TCB 21" | ClubFamilyName == "APEX 21" | ClubFamilyName == "APEX DCB 21" | ClubFamilyName == "APEX PRO 21 IRONS" | ClubFamilyName == "APEX MB 21")

#rename clubs
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX TCB 21" ] <- "APEX_TCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX 21" ] <- "APEX_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX DCB 21" ] <- "APEX_DCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX PRO 21 IRONS" ] <- "APEX_PRO_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX MB 21" ] <- "APEX_MB_21"

#remove NA
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(!is.na(ClubFamilyName), !is.na(ImpactHeadSpeedMph)) 

#plot to check outliers
ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = SmashFactor)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = ImpactHeadSpeedMph)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = ImpactVertLocInch)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()

ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallSpeedMph)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallLaunchAngleDeg)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallSideAngleDeg)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallBackSpinRpm)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallSideSpinRpm)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()

#remove bounds
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(SmashFactor > 1, SmashFactor < 1.4, ImpactHeadSpeedMph < 110, ImpactHeadSpeedMph > 50, BallSpeedMph < 140, BallSpeedMph > 70, BallLaunchAngleDeg > 5, BallLaunchAngleDeg < 30, BallSideAngleDeg < 5, BallSideAngleDeg > -5, BallBackSpinRpm > 4000, BallBackSpinRpm < 9000, BallSideSpinRpm < 2000, BallSideSpinRpm > -2000)

#select features
data <- Data_Engage_Quad_Carlsbad_Iron_Select %>% select(ClubFamilyName, ImpactHeadSpeedMph, BallSpeedMph, BallLaunchAngleDeg, BallSideAngleDeg, BallBackSpinRpm, BallSideSpinRpm)

#unique features
data <- unique(data)

#manualing scaling specific features
#data <- data %>% mutate(value = 1)  %>% spread(ClubFamilyName, value,  fill = 0)
#maxs <- apply(data%>% select(where(is.numeric)), 2, max) 
#mins <- apply(data%>% select(where(is.numeric)), 2, min)
#data_scaled <- as.data.frame(scale(data%>% select(where(is.numeric)), center = mins, scale = maxs - mins))

#dummy code for neural net
data <- data %>% mutate(value = 1)  %>% spread(ClubFamilyName, value,  fill = 0)

#subset into train and test
inTrain <- createDataPartition(
  y = data$ImpactHeadSpeedMph,
  times = 1,
  p = .8,
  list = FALSE
)

training <- data[ inTrain,]
testing  <- data[-inTrain,]
Q_test_data <- data.frame(Ball.Speed.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Ball.Speed.quad)),
                       Launch.Angle.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Launch.Angle.quad)),
                       Side.Angle.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Side.Angle.quad)),
                       Back.Spin.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Back.Spin.quad)),
                       Side.Spin.quad = Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Side.Spin.quad)),
                       APEX_21 = 0,
                       APEX_DCB_21 = 0,
                       APEX_MB_21 = 1,
                       APEX_PRO_21 = 0,
                       APEX_TCB_21 = 0)

colnames(Q_test_data) <- c("BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg", "BallBackSpinRpm", "BallSideSpinRpm", "APEX_21", "APEX_DCB_21", "APEX_MB_21", "APEX_PRO_21", "APEX_TCB_21")

registerDoMC(cores=4)

#models tried, xgbLinear, xgbtree, ols, mem, randforest, neuralnet
tune.grid.neuralnet <- expand.grid(
  layer1 = c(1:10), # first hidden layer, from 1 to 5 neurons
  layer2 = c(0), # second hidden layer, from 0 to 5 neurons
  layer3 = c(0)  # third hidden layer, from 0 to 5 neurons
)

# preProcValues <- preProcess(training, method = c("range"))
# trainTransformed <- predict(preProcValues, training)

#to do, 
# look at distribution of the scaled inputs and outputs
# in between number of inputs and outputs
# check minimizing loss
# run layer 1, 1, 2, 5, 10, 20, 
# stepmax, plot step as a function of loss.
# look into dropout and adaptive learning


system.time(model <- caret::train(ImpactHeadSpeedMph ~ ., data = training, method = "neuralnet",
                                  preProcess = c("center", "scale"), # data preprocessing
                                  tuneGrid = tune.grid.neuralnet, #dataframe of tunning values
                                  #size = c(1, 2, 5, 10, 20, 100),
                                  #metric = "RMSE", #summary metric for selecting the optimal model
                                  #stepmax = 1000, #maximum steps for the training
                                  #learningrate = 0.005, #amount that the weights are updated during training, try .005 or .001
                                  #threshold = 2,
                                  # preProcess = list(center = c("ImpactHeadSpeedMph", "BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg",
                                  #                                 "BallBackSpinRpm", "BallSideSpinRpm"),
                                  #                      scale = c("ImpactHeadSpeedMph", "BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg",
                                  #                                 "BallBackSpinRpm", "BallSideSpinRpm")),
                                  #linout = TRUE,
                                  trControl = trainControl(method = 'cv', number = 3, verboseIter = TRUE) #odd numbers, 3 or 5
                                  ))

#saveRDS(model, file = "nn_test.rda")
model <- readRDS(file = "nn_5_0_0.rda")

plot(model)
print(model)
plotnet(model, pad_x = .5)


result_predict <- predict(model,testing)
#result_predict_unscaled <- result_predict * ((max(data$ImpactHeadSpeedMph)-min(data$ImpactHeadSpeedMph))+min(data$ImpactHeadSpeedMph))
predict(model, Q_test_data)
Data.Combined.7I %>% filter(Player == "Quenten Hooker") %>% summarise(mean(Club.Speed.quad))




Final_Data <- cbind(Actual=testing$ImpactHeadSpeedMph,Predicted=result_predict)
Final_Data <- as.data.frame(Final_Data)

error <- (Final_Data$Actual- Final_Data$Predicted)
Final_Data <- cbind(Final_Data,error)

Final_Data <- Final_Data %>% na.omit()

rmse1<-sqrt(mean(Final_Data$error^2))
rmse1

MSE.mem <- sum((Final_Data$error)^2)/nrow(testing)
MSE.mem

ggplot(Final_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm") + annotate(geom="text", x=60, y=110, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=60, y=105, label= paste("RMSE = ", round(rmse1, 2)))


```


# xgboost attempt - clubheadspeed
```{r , echo=FALSE, include = TRUE, warning = TRUE}

#library(quantmod) 
#library(nnet)
library('doMC')
library('tensorflow')
library('caret')
library('NeuralNetTools')

#set generator for consistency
set.seed(1234)

#select correct clubs
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons", ClubFamilyName == "APEX TCB 21" | ClubFamilyName == "APEX 21" | ClubFamilyName == "APEX DCB 21" | ClubFamilyName == "APEX PRO 21 IRONS" | ClubFamilyName == "APEX MB 21")

#rename clubs
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX TCB 21" ] <- "APEX_TCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX 21" ] <- "APEX_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX DCB 21" ] <- "APEX_DCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX PRO 21 IRONS" ] <- "APEX_PRO_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX MB 21" ] <- "APEX_MB_21"

Data_Engage_Quad_Carlsbad_Iron_Select <- within(Data_Engage_Quad_Carlsbad_Iron_Select, {
  ClubFamilyName <- factor(as.character(ClubFamilyName))})

# #plot to check outliers
# ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = SmashFactor)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
# ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = ImpactHeadSpeedMph)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
# ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = ImpactAttackAngleDeg)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
ggplot(Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(ImpactPitchAngleDeg < 50), aes(x = ImpactPitchAngleDeg)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
# ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallSpeedMph)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
# ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallLaunchAngleDeg)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
# ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallSideAngleDeg)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
# ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallBackSpinRpm)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()
# ggplot(Data_Engage_Quad_Carlsbad_Iron_Select, aes(x = BallSideSpinRpm)) + geom_histogram(aes(y = ..density..), colour = 1, fill = "white") +  geom_density()

#remove NA
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(!is.na(ClubFamilyName), !is.na(ImpactHeadSpeedMph), !is.na(ImpactAttackAngleDeg), !is.na(ImpactPitchAngleDeg)) 

#remove bounds of distribution 
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(
  SmashFactor < mean(SmashFactor) + 2*sd(SmashFactor), SmashFactor > mean(SmashFactor) - 2*sd(SmashFactor),
  ImpactHeadSpeedMph < mean(ImpactHeadSpeedMph) + 2*sd(ImpactHeadSpeedMph), ImpactHeadSpeedMph > mean(ImpactHeadSpeedMph) - 2*sd(ImpactHeadSpeedMph),
  ImpactAttackAngleDeg < mean(ImpactAttackAngleDeg) + 2*sd(ImpactAttackAngleDeg), ImpactAttackAngleDeg > mean(ImpactAttackAngleDeg) - 2*sd(ImpactAttackAngleDeg),
  ImpactPitchAngleDeg < mean(ImpactPitchAngleDeg) + 2*sd(ImpactPitchAngleDeg), ImpactPitchAngleDeg > mean(ImpactPitchAngleDeg) - 2*sd(ImpactPitchAngleDeg),
  BallSpeedMph < mean(BallSpeedMph) + 2*sd(BallSpeedMph), BallSpeedMph > mean(BallSpeedMph) - 2*sd(BallSpeedMph),
  BallLaunchAngleDeg < mean(BallLaunchAngleDeg) + 2*sd(BallLaunchAngleDeg), BallLaunchAngleDeg > mean(BallLaunchAngleDeg) - 2*sd(BallLaunchAngleDeg),
  BallSideAngleDeg < mean(BallSideAngleDeg) + 2*sd(BallSideAngleDeg), BallSideAngleDeg > mean(BallSideAngleDeg) - 2*sd(BallSideAngleDeg),
  BallBackSpinRpm < mean(BallBackSpinRpm) + 2*sd(BallBackSpinRpm), BallBackSpinRpm > mean(BallBackSpinRpm) - 2*sd(BallBackSpinRpm),
  BallSideSpinRpm < mean(BallSideSpinRpm) + 2*sd(BallSideSpinRpm), BallSideSpinRpm > mean(BallSideSpinRpm) - 2*sd(BallSideSpinRpm))

#select features
data <- Data_Engage_Quad_Carlsbad_Iron_Select %>% select(ClubFamilyName, ImpactHeadSpeedMph, BallSpeedMph, BallLaunchAngleDeg, BallSideAngleDeg, BallBackSpinRpm, BallSideSpinRpm)

#unique features
data <- unique(data)
nrow(data)
#subset into train and test
inTrain <- createDataPartition(
  y = data$ImpactHeadSpeedMph,
  times = 1,
  p = .80,
  list = FALSE
)

training <- data[ inTrain,]
testing  <- data[-inTrain,]

registerDoMC(cores=4)

xgbGrid <- expand.grid(nrounds = c(50), #number of decision trees i the final model
                       lambda = c(.1, .5), #L2 regularization on leaf weights
                       alpha = c(.0001, .001, .01), # L1 regularization on leaf weights 
                       eta = c(.05, .3)) # learning rate

#xgboost
system.time(model <- caret::train(ImpactHeadSpeedMph ~ ., data = training, method = "xgbLinear",
                                  preProcess = c("center", "scale"),
                                  tuneGrid = xgbGrid, #dataframe of tunning values
                                  #metric = "RMSE", #summary metric for selecting the optimal model
                                  trControl = trainControl(method = 'cv', number = 5, verboseIter = TRUE)
                                  ))

#saveRDS(model, file = "xgbLinear_test.rda")
#model <- readRDS(file = "xgbLinear_test.rda")
#model <- readRDS(file = "xgbLinear_speed.rda")

#Engage test sample
# class(model)
# plot(model)
# print(model)
# print(model$finalModel)
# print(model1$finalModel)


result_predict <- predict(model,testing, na.action = na.omit)
Engage_Data <- cbind(Actual=testing$ImpactHeadSpeedMph,Predicted=result_predict)
Engage_Data <- as.data.frame(Engage_Data)

error <- (Engage_Data$Actual- Engage_Data$Predicted)
Engage_Data <- cbind(Engage_Data,error)

Engage_Data <- Engage_Data %>% na.omit()

rmse1<-sqrt(mean(Engage_Data$error^2))
rmse1

MSE.mem <- sum((Engage_Data$error)^2)/nrow(testing)
MSE.mem

ggplot(Engage_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm") + annotate(geom="text", x=60, y=110, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=60, y=105, label= paste("RMSE = ", round(rmse1, 2))) + xlim(50,110) + ylim(50,110)



#ECPC test sample 
ECPC <- Data.Combined.7I %>% filter(Tags == "MB21" | Tags == "TCB") %>% group_by(Player, Tags) %>% summarise(Ball.Speed.quad = mean(na.omit(Ball.Speed.quad)), Launch.Angle.quad = mean(na.omit(Launch.Angle.quad)), Side.Angle.quad = mean(na.omit(Side.Angle.quad)), Back.Spin.quad = mean(na.omit(Back.Spin.quad)),  Side.Spin.quad = mean(na.omit(Side.Spin.quad)))

ECPC$Tags[ECPC$Tags == "MB21" ] <- "APEX_MB_21"
ECPC$Tags[ECPC$Tags == "TCB" ] <- "APEX_TCB_21"

colnames(ECPC) <- c("Player", "ClubFamilyName", "BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg", "BallBackSpinRpm", "BallSideSpinRpm")

ECPC_Sum <- Data.Combined.7I %>% filter(Tags == "MB21" | Tags == "TCB") %>% group_by(Player, Tags) %>% summarise(mean(Club.Speed.quad))
colnames(ECPC_Sum) <- c("Player", "ClubFamilyName", "Actual")

result_predict <- predict(model,ECPC, na.action = na.omit)
ECPC_Data <- cbind(Actual=ECPC_Sum$Actual,Predicted=result_predict)
ECPC_Data <- as.data.frame(ECPC_Data)

error <- (ECPC_Data$Actual- ECPC_Data$Predicted)
ECPC_Data <- cbind(ECPC_Data,error)

ECPC_Data <- ECPC_Data %>% na.omit()

rmse1<-sqrt(mean(ECPC_Data$error^2))
rmse1

MSE.mem <- sum((ECPC_Data$error)^2)/nrow(ECPC_Data)
MSE.mem

ggplot(ECPC_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm") + annotate(geom="text", x=90, y=110, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=90, y=108, label= paste("RMSE = ", round(rmse1, 2)))

#Data.Combined.7I %>% filter(Player == "Ryan Curlee")  
```


# xgboost attempt - attack
```{r , echo=FALSE, include = TRUE, warning = TRUE}

#library(quantmod) 
#library(nnet)
library('doMC')
library('tensorflow')
library('caret')
library('NeuralNetTools')

#set generator for consistency
set.seed(1234)

#select correct clubs
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons", ClubFamilyName == "APEX TCB 21" | ClubFamilyName == "APEX 21" | ClubFamilyName == "APEX DCB 21" | ClubFamilyName == "APEX PRO 21 IRONS" | ClubFamilyName == "APEX MB 21")

#rename clubs
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX TCB 21" ] <- "APEX_TCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX 21" ] <- "APEX_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX DCB 21" ] <- "APEX_DCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX PRO 21 IRONS" ] <- "APEX_PRO_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX MB 21" ] <- "APEX_MB_21"

Data_Engage_Quad_Carlsbad_Iron_Select <- within(Data_Engage_Quad_Carlsbad_Iron_Select, {
  ClubFamilyName <- factor(as.character(ClubFamilyName))})

#remove NA
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(!is.na(ClubFamilyName), !is.na(ImpactHeadSpeedMph), !is.na(ImpactAttackAngleDeg), !is.na(ImpactPitchAngleDeg)) 

#remove bounds of distribution 
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(
  SmashFactor < mean(SmashFactor) + 2*sd(SmashFactor), SmashFactor > mean(SmashFactor) - 2*sd(SmashFactor),
  ImpactHeadSpeedMph < mean(ImpactHeadSpeedMph) + 2*sd(ImpactHeadSpeedMph), ImpactHeadSpeedMph > mean(ImpactHeadSpeedMph) - 2*sd(ImpactHeadSpeedMph),
  ImpactAttackAngleDeg < mean(ImpactAttackAngleDeg) + 2*sd(ImpactAttackAngleDeg), ImpactAttackAngleDeg > mean(ImpactAttackAngleDeg) - 2*sd(ImpactAttackAngleDeg),
  ImpactPitchAngleDeg < mean(ImpactPitchAngleDeg) + 2*sd(ImpactPitchAngleDeg), ImpactPitchAngleDeg > mean(ImpactPitchAngleDeg) - 2*sd(ImpactPitchAngleDeg),
  BallSpeedMph < mean(BallSpeedMph) + 2*sd(BallSpeedMph), BallSpeedMph > mean(BallSpeedMph) - 2*sd(BallSpeedMph),
  BallLaunchAngleDeg < mean(BallLaunchAngleDeg) + 2*sd(BallLaunchAngleDeg), BallLaunchAngleDeg > mean(BallLaunchAngleDeg) - 2*sd(BallLaunchAngleDeg),
  BallSideAngleDeg < mean(BallSideAngleDeg) + 2*sd(BallSideAngleDeg), BallSideAngleDeg > mean(BallSideAngleDeg) - 2*sd(BallSideAngleDeg),
  BallBackSpinRpm < mean(BallBackSpinRpm) + 2*sd(BallBackSpinRpm), BallBackSpinRpm > mean(BallBackSpinRpm) - 2*sd(BallBackSpinRpm),
  BallSideSpinRpm < mean(BallSideSpinRpm) + 2*sd(BallSideSpinRpm), BallSideSpinRpm > mean(BallSideSpinRpm) - 2*sd(BallSideSpinRpm))

#select features
data <- Data_Engage_Quad_Carlsbad_Iron_Select %>% select(ClubFamilyName, ImpactAttackAngleDeg, BallSpeedMph, BallLaunchAngleDeg, BallSideAngleDeg, BallBackSpinRpm, BallSideSpinRpm)

#unique features
data <- unique(data)

#subset into train and test
inTrain <- createDataPartition(
  y = data$ImpactAttackAngleDeg,
  times = 1,
  p = .80,
  list = FALSE
)

training <- data[ inTrain,]
testing  <- data[-inTrain,]

registerDoMC(cores=4)

#xgboost
system.time(model <- caret::train(ImpactAttackAngleDeg ~ ., data = training, method = "xgbLinear",
                                  #preProcess = c("center", "scale"),
                                  #tuneGrid = tune.grid.neuralnet, #dataframe of tunning values
                                  metric = "RMSE", #summary metric for selecting the optimal model
                                  trControl = trainControl(method = 'cv', number = 3, verboseIter = TRUE)
                                  ))

#saveRDS(model, file = "xgbLinear_attack.rda")
model <- readRDS(file = "xgbLinear_attack.rda")

#Engage test sample
class(model)
plot(model)
print(model)

result_predict <- predict(model,testing, na.action = na.omit)
Engage_Data <- cbind(Actual=testing$ImpactAttackAngleDeg,Predicted=result_predict)
Engage_Data <- as.data.frame(Engage_Data)

error <- (Engage_Data$Actual- Engage_Data$Predicted)
Engage_Data <- cbind(Engage_Data,error)

Engage_Data <- Engage_Data %>% na.omit()

rmse1<-sqrt(mean(Engage_Data$error^2))
rmse1

MSE.mem <- sum((Engage_Data$error)^2)/nrow(testing)
MSE.mem

ggplot(Engage_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm") + annotate(geom="text", x=-5, y=4, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=-5, y=5, label= paste("RMSE = ", round(rmse1, 2)))



#ECPC test sample 
ECPC <- Data.Combined.7I %>% filter(Tags == "MB21" | Tags == "TCB") %>% group_by(Player, Tags) %>% summarise(Ball.Speed.quad = mean(na.omit(Ball.Speed.quad)), Launch.Angle.quad = mean(na.omit(Launch.Angle.quad)), Side.Angle.quad = mean(na.omit(Side.Angle.quad)), Back.Spin.quad = mean(na.omit(Back.Spin.quad)),  Side.Spin.quad = mean(na.omit(Side.Spin.quad)))

ECPC$Tags[ECPC$Tags == "MB21" ] <- "APEX_MB_21"
ECPC$Tags[ECPC$Tags == "TCB" ] <- "APEX_TCB_21"

colnames(ECPC) <- c("Player", "ClubFamilyName", "BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg", "BallBackSpinRpm", "BallSideSpinRpm")

ECPC_Sum <- Data.Combined.7I %>% filter(Tags == "MB21" | Tags == "TCB") %>% group_by(Player, Tags) %>% summarise(mean(Angle.Of.Attack.quad))
colnames(ECPC_Sum) <- c("Player", "ClubFamilyName", "Actual")

result_predict <- predict(model,ECPC, na.action = na.omit)
ECPC_Data <- cbind(Actual=ECPC_Sum$Actual,Predicted=result_predict)
ECPC_Data <- as.data.frame(ECPC_Data)

error <- (ECPC_Data$Actual- ECPC_Data$Predicted)
ECPC_Data <- cbind(ECPC_Data,error)

ECPC_Data <- ECPC_Data %>% na.omit()

rmse1<-sqrt(mean(ECPC_Data$error^2))
rmse1

MSE.mem <- sum((ECPC_Data$error)^2)/nrow(ECPC_Data)
MSE.mem

ggplot(ECPC_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm") + annotate(geom="text", x=-5, y=4, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=-5, y=5, label= paste("RMSE = ", round(rmse1, 2)))

#Data.Combined.7I %>% filter(Player == "Ryan Curlee")


```

# xgboost attempt - pitch
```{r , echo=FALSE, include = TRUE, warning = TRUE}

#library(quantmod) 
#library(nnet)
library('doMC')
library('tensorflow')
library('caret')
library('NeuralNetTools')

#set generator for consistency
set.seed(1234)

#select correct clubs
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons", ClubFamilyName == "APEX TCB 21" | ClubFamilyName == "APEX 21" | ClubFamilyName == "APEX DCB 21" | ClubFamilyName == "APEX PRO 21 IRONS" | ClubFamilyName == "APEX MB 21")

#rename clubs
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX TCB 21" ] <- "APEX_TCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX 21" ] <- "APEX_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX DCB 21" ] <- "APEX_DCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX PRO 21 IRONS" ] <- "APEX_PRO_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX MB 21" ] <- "APEX_MB_21"

Data_Engage_Quad_Carlsbad_Iron_Select <- within(Data_Engage_Quad_Carlsbad_Iron_Select, {
  ClubFamilyName <- factor(as.character(ClubFamilyName))})

#remove NA
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(!is.na(ClubFamilyName), !is.na(ImpactHeadSpeedMph), !is.na(ImpactAttackAngleDeg), !is.na(ImpactPitchAngleDeg)) 

#remove bounds of distribution 
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(
  SmashFactor < mean(SmashFactor) + 2*sd(SmashFactor), SmashFactor > mean(SmashFactor) - 2*sd(SmashFactor),
  ImpactHeadSpeedMph < mean(ImpactHeadSpeedMph) + 2*sd(ImpactHeadSpeedMph), ImpactHeadSpeedMph > mean(ImpactHeadSpeedMph) - 2*sd(ImpactHeadSpeedMph),
  ImpactAttackAngleDeg < mean(ImpactAttackAngleDeg) + 2*sd(ImpactAttackAngleDeg), ImpactAttackAngleDeg > mean(ImpactAttackAngleDeg) - 2*sd(ImpactAttackAngleDeg),
  ImpactPitchAngleDeg < mean(ImpactPitchAngleDeg) + 2*sd(ImpactPitchAngleDeg), ImpactPitchAngleDeg > mean(ImpactPitchAngleDeg) - 2*sd(ImpactPitchAngleDeg),
  BallSpeedMph < mean(BallSpeedMph) + 2*sd(BallSpeedMph), BallSpeedMph > mean(BallSpeedMph) - 2*sd(BallSpeedMph),
  BallLaunchAngleDeg < mean(BallLaunchAngleDeg) + 2*sd(BallLaunchAngleDeg), BallLaunchAngleDeg > mean(BallLaunchAngleDeg) - 2*sd(BallLaunchAngleDeg),
  BallSideAngleDeg < mean(BallSideAngleDeg) + 2*sd(BallSideAngleDeg), BallSideAngleDeg > mean(BallSideAngleDeg) - 2*sd(BallSideAngleDeg),
  BallBackSpinRpm < mean(BallBackSpinRpm) + 2*sd(BallBackSpinRpm), BallBackSpinRpm > mean(BallBackSpinRpm) - 2*sd(BallBackSpinRpm),
  BallSideSpinRpm < mean(BallSideSpinRpm) + 2*sd(BallSideSpinRpm), BallSideSpinRpm > mean(BallSideSpinRpm) - 2*sd(BallSideSpinRpm))

#select features
data <- Data_Engage_Quad_Carlsbad_Iron_Select %>% select(ClubFamilyName, ImpactPitchAngleDeg, BallSpeedMph, BallLaunchAngleDeg, BallSideAngleDeg, BallBackSpinRpm, BallSideSpinRpm)

#unique features
data <- unique(data)

#subset into train and test
inTrain <- createDataPartition(
  y = data$ImpactPitchAngleDeg,
  times = 1,
  p = .80,
  list = FALSE
)

training <- data[ inTrain,]
testing  <- data[-inTrain,]

registerDoMC(cores=4)

#xgboost
system.time(model <- caret::train(ImpactPitchAngleDeg ~ ., data = training, method = "xgbLinear",
                                  #preProcess = c("center", "scale"),
                                  #tuneGrid = tune.grid.neuralnet, #dataframe of tunning values
                                  metric = "RMSE", #summary metric for selecting the optimal model
                                  trControl = trainControl(method = 'cv', number = 3, verboseIter = TRUE)
                                  ))

saveRDS(model, file = "xgbLinear_loft.rda")
#model <- readRDS(file = "xgbLinear.rda")

#Engage test sample
class(model)
plot(model)
print(model)

result_predict <- predict(model,testing, na.action = na.omit)
Engage_Data <- cbind(Actual=testing$ImpactPitchAngleDeg,Predicted=result_predict)
Engage_Data <- as.data.frame(Engage_Data)

error <- (Engage_Data$Actual- Engage_Data$Predicted)
Engage_Data <- cbind(Engage_Data,error)

Engage_Data <- Engage_Data %>% na.omit()

rmse1<-sqrt(mean(Engage_Data$error^2))
rmse1

MSE.mem <- sum((Engage_Data$error)^2)/nrow(testing)
MSE.mem

ggplot(Engage_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm") + annotate(geom="text", x=25, y=40, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=25, y=39, label= paste("RMSE = ", round(rmse1, 2)))



#ECPC test sample 
ECPC <- Data.Combined.7I %>% filter(Tags == "MB21" | Tags == "TCB") %>% group_by(Player, Tags) %>% summarise(Ball.Speed.quad = mean(na.omit(Ball.Speed.quad)), Launch.Angle.quad = mean(na.omit(Launch.Angle.quad)), Side.Angle.quad = mean(na.omit(Side.Angle.quad)), Back.Spin.quad = mean(na.omit(Back.Spin.quad)),  Side.Spin.quad = mean(na.omit(Side.Spin.quad)))

ECPC$Tags[ECPC$Tags == "MB21" ] <- "APEX_MB_21"
ECPC$Tags[ECPC$Tags == "TCB" ] <- "APEX_TCB_21"

colnames(ECPC) <- c("Player", "ClubFamilyName", "BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg", "BallBackSpinRpm", "BallSideSpinRpm")

ECPC_Sum <- Data.Combined.7I %>% filter(Tags == "MB21" | Tags == "TCB") %>% group_by(Player, Tags) %>% summarise(mean(Loft.quad))
colnames(ECPC_Sum) <- c("Player", "ClubFamilyName", "Actual")

result_predict <- predict(model,ECPC, na.action = na.omit)
ECPC_Data <- cbind(Actual=ECPC_Sum$Actual,Predicted=result_predict)
ECPC_Data <- as.data.frame(ECPC_Data)

error <- (ECPC_Data$Actual- ECPC_Data$Predicted)
ECPC_Data <- cbind(ECPC_Data,error)

ECPC_Data <- ECPC_Data %>% na.omit()

rmse1<-sqrt(mean(ECPC_Data$error^2))
rmse1

MSE.mem <- sum((ECPC_Data$error)^2)/nrow(ECPC_Data)
MSE.mem

ggplot(ECPC_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm") + annotate(geom="text", x=25, y=40, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=25, y=39, label= paste("RMSE = ", round(rmse1, 2)))

#Data.Combined.7I %>% filter(Player == "Ryan Curlee")


```


# NN multiple outputs
```{r , echo=FALSE, include = TRUE, warning = TRUE}

#library(quantmod) 
library('nnet')
library('doMC')
library('tensorflow')
library('caret')
library('NeuralNetTools')
library('neuralnet')

#set generator for consistency
set.seed(1234)

#select correct clubs
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons", ClubFamilyName == "APEX TCB 21" | ClubFamilyName == "APEX 21" | ClubFamilyName == "APEX DCB 21" | ClubFamilyName == "APEX PRO 21 IRONS" | ClubFamilyName == "APEX MB 21")

#rename clubs
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX TCB 21" ] <- "APEX_TCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX 21" ] <- "APEX_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX DCB 21" ] <- "APEX_DCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX PRO 21 IRONS" ] <- "APEX_PRO_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX MB 21" ] <- "APEX_MB_21"

#remove NA
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(!is.na(ClubFamilyName), !is.na(ImpactHeadSpeedMph), !is.na(ImpactAttackAngleDeg), !is.na(ImpactPitchAngleDeg)) 

#remove bounds of distribution 
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(
  SmashFactor < mean(SmashFactor) + 2*sd(SmashFactor), SmashFactor > mean(SmashFactor) - 2*sd(SmashFactor),
  ImpactHeadSpeedMph < mean(ImpactHeadSpeedMph) + 2*sd(ImpactHeadSpeedMph), ImpactHeadSpeedMph > mean(ImpactHeadSpeedMph) - 2*sd(ImpactHeadSpeedMph),
  ImpactAttackAngleDeg < mean(ImpactAttackAngleDeg) + 2*sd(ImpactAttackAngleDeg), ImpactAttackAngleDeg > mean(ImpactAttackAngleDeg) - 2*sd(ImpactAttackAngleDeg),
  ImpactPitchAngleDeg < mean(ImpactPitchAngleDeg) + 2*sd(ImpactPitchAngleDeg), ImpactPitchAngleDeg > mean(ImpactPitchAngleDeg) - 2*sd(ImpactPitchAngleDeg),
  BallSpeedMph < mean(BallSpeedMph) + 2*sd(BallSpeedMph), BallSpeedMph > mean(BallSpeedMph) - 2*sd(BallSpeedMph),
  BallLaunchAngleDeg < mean(BallLaunchAngleDeg) + 2*sd(BallLaunchAngleDeg), BallLaunchAngleDeg > mean(BallLaunchAngleDeg) - 2*sd(BallLaunchAngleDeg),
  BallSideAngleDeg < mean(BallSideAngleDeg) + 2*sd(BallSideAngleDeg), BallSideAngleDeg > mean(BallSideAngleDeg) - 2*sd(BallSideAngleDeg),
  BallBackSpinRpm < mean(BallBackSpinRpm) + 2*sd(BallBackSpinRpm), BallBackSpinRpm > mean(BallBackSpinRpm) - 2*sd(BallBackSpinRpm),
  BallSideSpinRpm < mean(BallSideSpinRpm) + 2*sd(BallSideSpinRpm), BallSideSpinRpm > mean(BallSideSpinRpm) - 2*sd(BallSideSpinRpm))


# 
# SmashFactor < 1.4, ImpactHeadSpeedMph < 110, ImpactHeadSpeedMph > 50, ImpactAttackAngleDeg < 2, ImpactAttackAngleDeg > -10, ImpactPitchAngleDeg < 45, ImpactPitchAngleDeg > 10, BallSpeedMph < 140, BallSpeedMph > 70, BallLaunchAngleDeg > 5, BallLaunchAngleDeg < 30, BallSideAngleDeg < 5, BallSideAngleDeg > -5, BallBackSpinRpm > 2000, BallBackSpinRpm < 9000, BallSideSpinRpm < 2000, BallSideSpinRpm > -2000)

#select features for training
data <- Data_Engage_Quad_Carlsbad_Iron_Select %>% select(ClubFamilyName, ImpactHeadSpeedMph, ImpactAttackAngleDeg, ImpactPitchAngleDeg, BallSpeedMph, BallLaunchAngleDeg, BallSideAngleDeg, BallBackSpinRpm, BallSideSpinRpm)

#unique features
data <- unique(data)

#dummy code for neural net
data <- data %>% mutate(value = 1)  %>% spread(ClubFamilyName, value,  fill = 0)

#check for NAs
apply(data,2,function(x) sum(is.na(x)))

#separate train and test
index <- sample(1:nrow(data),round(0.80*nrow(data)))
train <- data[index,]
test <- data[-index,]

#parameters for scaling/normalizing data
maxs <- apply(data, 2, max) 
mins <- apply(data, 2, min)
means <- apply(data[,1:8], 2, mean)
sds <- apply(data[,1:8], 2, sd)

#scaling to 0 to 1
#scaled <- as.data.frame(scale(data, center = mins, scale = maxs - mins))

#scaling to mean = 0 and sd = 1
scaled <- as.data.frame(cbind(scale(data[,1:8], center = means, scale = sds), data[,9:13]))

train_ <- scaled[index,]
test_ <- scaled[-index,]

results_combined <- c()

#optional loop through defined net grid
for (i in 8) {
  
  #for(j in 1:5){
    
    #for(k in 1:5){
  
system.time(model <- neuralnet(ImpactHeadSpeedMph + ImpactAttackAngleDeg + ImpactPitchAngleDeg ~ BallSpeedMph + BallLaunchAngleDeg + BallSideAngleDeg + BallBackSpinRpm + BallSideSpinRpm + APEX_21 + APEX_DCB_21 + APEX_MB_21 + APEX_PRO_21 + APEX_TCB_21, #inputs and outputs
                data = train_, #train data
                hidden = c(i), #neuralnet grid
                threshold = 2, # threshold for the partial derivatives of the error function as stopping criteria
                stepmax = 1e+06, #the maximum steps for the training of the neural network
                rep = 1, #neuralnet training repetitions
                startweights = NULL, #starting weights, null is random
                #learningrate.limit = NULL, #lowest and highest limit for the learning rate
                #learningrate.factor = list(minus = 0.5,  plus = 1.2), #multiplication factors for the upper and lower learning rate
                learningrate = NULL, #learning rate used by traditional backpropagation
                lifesign = "full", #how much the function will print during the calculation of the neural network
                lifesign.step = 1000, #stepsize to print the minimal threshold in full lifesign mode
                algorithm = "rprop+", #algorithm type to calculate the neural network.
                err.fct = "sse", #function that is used for the calculation of the error
                act.fct = "logistic", #activation function to be applied to neuron weights
                linear.output = TRUE, #regression or classification problem
                exclude = NULL, # exclude any specific weights?
                constant.weights = NULL, # values of the weights that are excluded
                likelihood = FALSE #error function is equal to the negative log-likelihood function
                ))
  
#saveRDS(model, file = "nn_8_0_final.rda")
model <- readRDS(file = "nn_8_0_final.rda")
plot(model)
plotnet(model, pad_x = .5)

#predictions for test set
pr.nn <- compute(model,test_)

#organize actual vs. predictions
results <- data.frame(test_$ImpactHeadSpeedMph, test_$ImpactAttackAngleDeg, test_$ImpactPitchAngleDeg, pr.nn$net.result[,1], pr.nn$net.result[,2], pr.nn$net.result[,3])
colnames(results) <- c("test_ImpactHeadSpeedMph", "test_ImpactAttackAngleDeg", "test_ImpactPitchAngleDeg", "pred_ImpactHeadSpeedMph", "pred_ImpactAttackAngleDeg", "pred_ImpactPitchAngleDeg")

#unscaling to 0 to 1
# unscaled <- data.frame(test_ImpactHeadSpeedMph = results$test_ImpactHeadSpeedMph * abs(diff(range(data$ImpactHeadSpeedMph))) + min(data$ImpactHeadSpeedMph),
#                        test_ImpactAttackAngleDeg = results$test_ImpactAttackAngleDeg * abs(diff(range(data$ImpactAttackAngleDeg))) + min(data$ImpactAttackAngleDeg),
#                        test_ImpactPitchAngleDeg = results$test_ImpactPitchAngleDeg * abs(diff(range(data$ImpactPitchAngleDeg))) + min(data$ImpactPitchAngleDeg),
#                        pred_ImpactHeadSpeedMph = results$pred_ImpactHeadSpeedMph * abs(diff(range(data$ImpactHeadSpeedMph))) + min(data$ImpactHeadSpeedMph),
#                        pred_ImpactAttackAngleDeg = results$pred_ImpactAttackAngleDeg * abs(diff(range(data$ImpactAttackAngleDeg))) + min(data$ImpactAttackAngleDeg),
#                        pred_ImpactPitchAngleDeg = results$pred_ImpactPitchAngleDeg * abs(diff(range(data$ImpactPitchAngleDeg))) + min(data$ImpactPitchAngleDeg))

#unscaling to mean = 0 and sd = 1
unscaled <- data.frame(test_ImpactHeadSpeedMph = results$test_ImpactHeadSpeedMph * sds[['ImpactHeadSpeedMph']] + means[['ImpactHeadSpeedMph']],
                       test_ImpactAttackAngleDeg = results$test_ImpactAttackAngleDeg * sds[['ImpactAttackAngleDeg']] + means[['ImpactAttackAngleDeg']],
                       test_ImpactPitchAngleDeg = results$test_ImpactPitchAngleDeg * sds[['ImpactPitchAngleDeg']] + means[['ImpactPitchAngleDeg']],
                       pred_ImpactHeadSpeedMph = results$pred_ImpactHeadSpeedMph * sds[['ImpactHeadSpeedMph']] + means[['ImpactHeadSpeedMph']],
                       pred_ImpactAttackAngleDeg = results$pred_ImpactAttackAngleDeg * sds[['ImpactAttackAngleDeg']] + means[['ImpactAttackAngleDeg']],
                       pred_ImpactPitchAngleDeg = results$pred_ImpactPitchAngleDeg * sds[['ImpactPitchAngleDeg']] + means[['ImpactPitchAngleDeg']])

#error of unscaled results
unscaled <- unscaled %>% mutate(error_ImpactHeadSpeedMph = test_ImpactHeadSpeedMph - pred_ImpactHeadSpeedMph,
                                error_ImpactAttackAngleDeg = test_ImpactAttackAngleDeg - pred_ImpactAttackAngleDeg,
                                error_ImpactPitchAngleDeg = test_ImpactPitchAngleDeg - pred_ImpactPitchAngleDeg)

#root mean squared error of unscaled 
rmse <- unscaled %>% summarise(rmse_ImpactHeadSpeedMph = sqrt(mean(error_ImpactHeadSpeedMph^2)),
                               rmse_ImpactAttackAngleDeg = sqrt(mean(error_ImpactAttackAngleDeg^2)),
                               rmse_ImpactPitchAngleDeg = sqrt(mean(error_ImpactPitchAngleDeg^2)))

#store results
results <- cbind(layer_one_neuron = 8, rmse)
results_combined <- rbind(results_combined, results)

#}
#}
}

#results_combined1<- results_combined
#results_combined2<- results_combined


#print

# saveRDS(model, file = "nn_8_0_test.rda")

#8 and 8, 3 are performing the best at first scaling 0 to 1
#8, 5 are performing best with mean center and sd scaling

```

```{r , echo=FALSE, include = TRUE, warning = TRUE}

annotate_npc <- function(label, x, y, ...)
{
  ggplot2::annotation_custom(grid::textGrob(
    x = unit(x, "npc"), y = unit(y, "npc"), label = label, ...))
}

ggplot(unscaled, aes(x = test_ImpactHeadSpeedMph, y = pred_ImpactHeadSpeedMph)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse$rmse_ImpactHeadSpeedMph, 2)), 0.1, .95) + xlim(50,110) + ylim(50,110)

ggplot(unscaled, aes(x = test_ImpactAttackAngleDeg, y = pred_ImpactAttackAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse$rmse_ImpactAttackAngleDeg, 2)), 0.1, .95)  + xlim(-15,10) + ylim(-15,10)

ggplot(unscaled, aes(x = test_ImpactPitchAngleDeg, y = pred_ImpactPitchAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse$rmse_ImpactPitchAngleDeg, 2)), 0.1, .95) + xlim(10,50) + ylim(10,50)
```

```{r , echo=FALSE, include = TRUE, warning = TRUE}

#ECPC test sample 
ECPC <- Data.Combined.7I %>% filter(Tags == "MB21" | Tags == "TCB") %>% group_by(Player, Tags) %>% summarise(Club.Speed.quad = mean(na.omit(Club.Speed.quad)), Angle.Of.Attack.quad = mean(na.omit(Angle.Of.Attack.quad)), Loft.quad = mean(na.omit(Loft.quad)), Ball.Speed.quad = mean(na.omit(Ball.Speed.quad)), Launch.Angle.quad = mean(na.omit(Launch.Angle.quad)), Side.Angle.quad = mean(na.omit(Side.Angle.quad)), Back.Spin.quad = mean(na.omit(Back.Spin.quad)),  Side.Spin.quad = mean(na.omit(Side.Spin.quad)))

#remove NA
ECPC <- ECPC %>% filter(!is.na(Club.Speed.quad), !is.na(Angle.Of.Attack.quad), !is.na(Loft.quad)) 

ECPC$Tags[ECPC$Tags == "MB21" ] <- "APEX_MB_21"
ECPC$Tags[ECPC$Tags == "TCB" ] <- "APEX_TCB_21"

colnames(ECPC) <- c("Player", "ClubFamilyName","ImpactHeadSpeedMph", "ImpactAttackAngleDeg", "ImpactPitchAngleDeg" , "BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg", "BallBackSpinRpm", "BallSideSpinRpm")

ECPC <- ECPC %>% mutate(value = 1)  %>% spread(ClubFamilyName, value,  fill = 0)

#parameters for scaling/normalizing data
maxs <- apply(data, 2, max) 
mins <- apply(data, 2, min)
means <- apply(data[,1:8], 2, mean)
sds <- apply(data[,1:8], 2, sd)

#scaling to 0 to 1
#scaled <- as.data.frame(scale(data, center = mins, scale = maxs - mins))

#scaling to mean = 0 and sd = 1
scaled <- as.data.frame(cbind(scale(ECPC[,2:9], center = means, scale = sds), ECPC[,10:11], APEX_21 = 0, APEX_DCB_21 = 0, APEX_PRO_21 = 0))
scaled_input <- scaled %>% select(-ImpactHeadSpeedMph, -ImpactAttackAngleDeg, -ImpactPitchAngleDeg)

#predictions for test set
pr.nn <- compute(model,scaled_input)

#organize actual vs. predictions
results <- data.frame(scaled$ImpactHeadSpeedMph, scaled$ImpactAttackAngleDeg, scaled$ImpactPitchAngleDeg, pr.nn$net.result[,1], pr.nn$net.result[,2], pr.nn$net.result[,3])
colnames(results) <- c("test_ImpactHeadSpeedMph", "test_ImpactAttackAngleDeg", "test_ImpactPitchAngleDeg", "pred_ImpactHeadSpeedMph", "pred_ImpactAttackAngleDeg", "pred_ImpactPitchAngleDeg")

#unscaling to mean = 0 and sd = 1
unscaled_ECPC <- data.frame(test_ImpactHeadSpeedMph = results$test_ImpactHeadSpeedMph * sds[['ImpactHeadSpeedMph']] + means[['ImpactHeadSpeedMph']],
                       test_ImpactAttackAngleDeg = results$test_ImpactAttackAngleDeg * sds[['ImpactAttackAngleDeg']] + means[['ImpactAttackAngleDeg']],
                       test_ImpactPitchAngleDeg = results$test_ImpactPitchAngleDeg * sds[['ImpactPitchAngleDeg']] + means[['ImpactPitchAngleDeg']],
                       pred_ImpactHeadSpeedMph = results$pred_ImpactHeadSpeedMph * sds[['ImpactHeadSpeedMph']] + means[['ImpactHeadSpeedMph']],
                       pred_ImpactAttackAngleDeg = results$pred_ImpactAttackAngleDeg * sds[['ImpactAttackAngleDeg']] + means[['ImpactAttackAngleDeg']],
                       pred_ImpactPitchAngleDeg = results$pred_ImpactPitchAngleDeg * sds[['ImpactPitchAngleDeg']] + means[['ImpactPitchAngleDeg']])

#error of unscaled results
unscaled_ECPC <- unscaled_ECPC %>% mutate(error_ImpactHeadSpeedMph = test_ImpactHeadSpeedMph - pred_ImpactHeadSpeedMph,
                                error_ImpactAttackAngleDeg = test_ImpactAttackAngleDeg - pred_ImpactAttackAngleDeg,
                                error_ImpactPitchAngleDeg = test_ImpactPitchAngleDeg - pred_ImpactPitchAngleDeg)


#root mean squared error of unscaled 
rmse_ECPC <- unscaled_ECPC %>% summarise(rmse_ImpactHeadSpeedMph = sqrt(mean(error_ImpactHeadSpeedMph^2)),
                               rmse_ImpactAttackAngleDeg = sqrt(mean(error_ImpactAttackAngleDeg^2)),
                               rmse_ImpactPitchAngleDeg = sqrt(mean(error_ImpactPitchAngleDeg^2)))

#store results
results_ECPC <- cbind(layer_one_neuron = 8, rmse_ECPC)

ggplot(unscaled_ECPC, aes(x = test_ImpactHeadSpeedMph, y = pred_ImpactHeadSpeedMph)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse_ECPC$rmse_ImpactHeadSpeedMph, 2)), 0.1, .95) 

ggplot(unscaled_ECPC, aes(x = test_ImpactAttackAngleDeg, y = pred_ImpactAttackAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse_ECPC$rmse_ImpactAttackAngleDeg, 2)), 0.1, .95)  

ggplot(unscaled_ECPC, aes(x = test_ImpactPitchAngleDeg, y = pred_ImpactPitchAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse_ECPC$rmse_ImpactPitchAngleDeg, 2)), 0.1, .95) 

```


# NN multiple outputs - including more outputs
```{r , echo=FALSE, include = TRUE, warning = TRUE}

#library(quantmod) 
library('nnet')
library('doMC')
library('tensorflow')
library('caret')
library('NeuralNetTools')
library('neuralnet')

#set generator for consistency
set.seed(1234)

#select correct clubs
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad %>% filter(CategoryName == "Irons", ClubFamilyName == "APEX TCB 21" | ClubFamilyName == "APEX 21" | ClubFamilyName == "APEX DCB 21" | ClubFamilyName == "APEX PRO 21 IRONS" | ClubFamilyName == "APEX MB 21" | ClubFamilyName == "PARADYM IRONS" | ClubFamilyName == "PARADYM X IRONS")

#rename clubs
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX TCB 21" ] <- "APEX_TCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX 21" ] <- "APEX_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX DCB 21" ] <- "APEX_DCB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX PRO 21 IRONS" ] <- "APEX_PRO_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "APEX MB 21" ] <- "APEX_MB_21"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "PARADYM IRONS" ] <- "PARADYM_23"
Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName[Data_Engage_Quad_Carlsbad_Iron_Select$ClubFamilyName == "PARADYM X IRONS" ] <- "PARADYM_X_23"

#remove NA
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(!is.na(ClubFamilyName), !is.na(ImpactHeadSpeedMph), !is.na(ImpactAttackAngleDeg), !is.na(ImpactPitchAngleDeg)) 

#remove bounds of distribution 
Data_Engage_Quad_Carlsbad_Iron_Select <- Data_Engage_Quad_Carlsbad_Iron_Select %>% filter(
  SmashFactor < mean(SmashFactor) + 2*sd(SmashFactor), SmashFactor > mean(SmashFactor) - 2*sd(SmashFactor),
  ImpactHeadSpeedMph < mean(ImpactHeadSpeedMph) + 2*sd(ImpactHeadSpeedMph), ImpactHeadSpeedMph > mean(ImpactHeadSpeedMph) - 2*sd(ImpactHeadSpeedMph),
  ImpactAttackAngleDeg < mean(ImpactAttackAngleDeg) + 2*sd(ImpactAttackAngleDeg), ImpactAttackAngleDeg > mean(ImpactAttackAngleDeg) - 2*sd(ImpactAttackAngleDeg),
  ImpactPitchAngleDeg < mean(ImpactPitchAngleDeg) + 2*sd(ImpactPitchAngleDeg), ImpactPitchAngleDeg > mean(ImpactPitchAngleDeg) - 2*sd(ImpactPitchAngleDeg),
  ImpactYawAngleDeg < mean(ImpactYawAngleDeg) + 2*sd(ImpactYawAngleDeg), ImpactYawAngleDeg > mean(ImpactYawAngleDeg) - 2*sd(ImpactYawAngleDeg),
  ImpactPathAngleDeg < mean(ImpactPathAngleDeg) + 2*sd(ImpactPathAngleDeg), ImpactPathAngleDeg > mean(ImpactPathAngleDeg) - 2*sd(ImpactPathAngleDeg),
  ImpactHorizLocInch < mean(ImpactHorizLocInch) + 2*sd(ImpactHorizLocInch), ImpactHorizLocInch > mean(ImpactHorizLocInch) - 2*sd(ImpactHorizLocInch),
  ImpactVertLocInch < mean(ImpactVertLocInch) + 2*sd(ImpactVertLocInch), ImpactVertLocInch > mean(ImpactVertLocInch) - 2*sd(ImpactVertLocInch),
  BallSpeedMph < mean(BallSpeedMph) + 2*sd(BallSpeedMph), BallSpeedMph > mean(BallSpeedMph) - 2*sd(BallSpeedMph),
  BallLaunchAngleDeg < mean(BallLaunchAngleDeg) + 2*sd(BallLaunchAngleDeg), BallLaunchAngleDeg > mean(BallLaunchAngleDeg) - 2*sd(BallLaunchAngleDeg),
  BallSideAngleDeg < mean(BallSideAngleDeg) + 2*sd(BallSideAngleDeg), BallSideAngleDeg > mean(BallSideAngleDeg) - 2*sd(BallSideAngleDeg),
  BallBackSpinRpm < mean(BallBackSpinRpm) + 2*sd(BallBackSpinRpm), BallBackSpinRpm > mean(BallBackSpinRpm) - 2*sd(BallBackSpinRpm),
  BallSideSpinRpm < mean(BallSideSpinRpm) + 2*sd(BallSideSpinRpm), BallSideSpinRpm > mean(BallSideSpinRpm) - 2*sd(BallSideSpinRpm))

# 
# SmashFactor < 1.4, ImpactHeadSpeedMph < 110, ImpactHeadSpeedMph > 50, ImpactAttackAngleDeg < 2, ImpactAttackAngleDeg > -10, ImpactPitchAngleDeg < 45, ImpactPitchAngleDeg > 10, BallSpeedMph < 140, BallSpeedMph > 70, BallLaunchAngleDeg > 5, BallLaunchAngleDeg < 30, BallSideAngleDeg < 5, BallSideAngleDeg > -5, BallBackSpinRpm > 2000, BallBackSpinRpm < 9000, BallSideSpinRpm < 2000, BallSideSpinRpm > -2000)

#select features for training
data <- Data_Engage_Quad_Carlsbad_Iron_Select %>% select(ClubFamilyName, ImpactHeadSpeedMph, ImpactAttackAngleDeg, ImpactPitchAngleDeg, ImpactYawAngleDeg, ImpactPathAngleDeg, ImpactHorizLocInch, ImpactVertLocInch, BallSpeedMph, BallLaunchAngleDeg, BallSideAngleDeg, BallBackSpinRpm, BallSideSpinRpm)

#unique features
data <- unique(data)

#dummy code for neural net
data <- data %>% mutate(value = 1)  %>% spread(ClubFamilyName, value,  fill = 0)

#check for NAs
apply(data,2,function(x) sum(is.na(x)))

#separate train and test
index <- sample(1:nrow(data),round(0.80*nrow(data)))
train <- data[index,]
test <- data[-index,]

#parameters for scaling/normalizing data
maxs <- apply(data, 2, max) 
mins <- apply(data, 2, min)
means <- apply(data[,1:12], 2, mean)
sds <- apply(data[,1:12], 2, sd)

#scaling to 0 to 1
#scaled <- as.data.frame(scale(data, center = mins, scale = maxs - mins))

#scaling to mean = 0 and sd = 1
scaled <- as.data.frame(cbind(scale(data[,1:12], center = means, scale = sds), data[,13:19]))

train_ <- scaled[index,]
test_ <- scaled[-index,]

results_combined <- c()

#optional loop through defined net grid
for (i in 5:10) {
  
  #for(j in 1:5){
    
    #for(k in 1:5){
  
system.time(model <- neuralnet(ImpactHeadSpeedMph + ImpactAttackAngleDeg + ImpactPitchAngleDeg + ImpactYawAngleDeg + ImpactPathAngleDeg ~ BallSpeedMph + BallLaunchAngleDeg + BallSideAngleDeg + BallBackSpinRpm + BallSideSpinRpm + APEX_21 + APEX_DCB_21 + APEX_MB_21 + APEX_PRO_21 + APEX_TCB_21, #inputs and outputs
                data = train_, #train data
                hidden = c(8), #neuralnet grid
                threshold = .75, # threshold for the partial derivatives of the error function as stopping criteria
                stepmax = 1e+06, #the maximum steps for the training of the neural network
                rep = 1, #neuralnet training repetitions
                startweights = NULL, #starting weights, null is random
                #learningrate.limit = NULL, #lowest and highest limit for the learning rate
                #learningrate.factor = list(minus = 0.5,  plus = 1.2), #multiplication factors for the upper and lower learning rate
                learningrate = NULL, #learning rate used by traditional backpropagation
                lifesign = "full", #how much the function will print during the calculation of the neural network
                lifesign.step = 1000, #stepsize to print the minimal threshold in full lifesign mode
                algorithm = "rprop+", #algorithm type to calculate the neural network.
                err.fct = "sse", #function that is used for the calculation of the error
                act.fct = "logistic", #activation function to be applied to neuron weights
                linear.output = TRUE, #regression or classification problem
                exclude = NULL, # exclude any specific weights?
                constant.weights = NULL, # values of the weights that are excluded
                likelihood = FALSE #error function is equal to the negative log-likelihood function
                ))
  
saveRDS(model, file = "nn_12_8_5_paradym.rda")
#model <- readRDS(file = "nn_8_0_final.rda")
#plot(model)
#plotnet(model, pad_x = .5)

#predictions for test set
pr.nn <- compute(model,test_)

#organize actual vs. predictions
results <- data.frame(test_$ImpactHeadSpeedMph, test_$ImpactAttackAngleDeg, test_$ImpactPitchAngleDeg , test_$ImpactYawAngleDeg , test_$ImpactPathAngleDeg, pr.nn$net.result[,1], pr.nn$net.result[,2], pr.nn$net.result[,3], pr.nn$net.result[,4], pr.nn$net.result[,5])
colnames(results) <- c("test_ImpactHeadSpeedMph", "test_ImpactAttackAngleDeg", "test_ImpactPitchAngleDeg", "test_ImpactYawAngleDeg", "test_ImpactPathAngleDeg", "pred_ImpactHeadSpeedMph", "pred_ImpactAttackAngleDeg", "pred_ImpactPitchAngleDeg" , "pred_ImpactYawAngleDeg" , "pred_ImpactPathAngleDeg")

#unscaling to 0 to 1
# unscaled <- data.frame(test_ImpactHeadSpeedMph = results$test_ImpactHeadSpeedMph * abs(diff(range(data$ImpactHeadSpeedMph))) + min(data$ImpactHeadSpeedMph),
#                        test_ImpactAttackAngleDeg = results$test_ImpactAttackAngleDeg * abs(diff(range(data$ImpactAttackAngleDeg))) + min(data$ImpactAttackAngleDeg),
#                        test_ImpactPitchAngleDeg = results$test_ImpactPitchAngleDeg * abs(diff(range(data$ImpactPitchAngleDeg))) + min(data$ImpactPitchAngleDeg),
#                        pred_ImpactHeadSpeedMph = results$pred_ImpactHeadSpeedMph * abs(diff(range(data$ImpactHeadSpeedMph))) + min(data$ImpactHeadSpeedMph),
#                        pred_ImpactAttackAngleDeg = results$pred_ImpactAttackAngleDeg * abs(diff(range(data$ImpactAttackAngleDeg))) + min(data$ImpactAttackAngleDeg),
#                        pred_ImpactPitchAngleDeg = results$pred_ImpactPitchAngleDeg * abs(diff(range(data$ImpactPitchAngleDeg))) + min(data$ImpactPitchAngleDeg))

#unscaling to mean = 0 and sd = 1
unscaled <- data.frame(test_ImpactHeadSpeedMph = results$test_ImpactHeadSpeedMph * sds[['ImpactHeadSpeedMph']] + means[['ImpactHeadSpeedMph']],
                       test_ImpactAttackAngleDeg = results$test_ImpactAttackAngleDeg * sds[['ImpactAttackAngleDeg']] + means[['ImpactAttackAngleDeg']],
                       test_ImpactPitchAngleDeg = results$test_ImpactPitchAngleDeg * sds[['ImpactPitchAngleDeg']] + means[['ImpactPitchAngleDeg']],
                       test_ImpactYawAngleDeg = results$test_ImpactYawAngleDeg * sds[['ImpactYawAngleDeg']] + means[['ImpactYawAngleDeg']],
                       test_ImpactPathAngleDeg = results$test_ImpactPathAngleDeg * sds[['ImpactPathAngleDeg']] + means[['ImpactPathAngleDeg']],
                       pred_ImpactHeadSpeedMph = results$pred_ImpactHeadSpeedMph * sds[['ImpactHeadSpeedMph']] + means[['ImpactHeadSpeedMph']],
                       pred_ImpactAttackAngleDeg = results$pred_ImpactAttackAngleDeg * sds[['ImpactAttackAngleDeg']] + means[['ImpactAttackAngleDeg']],
                       pred_ImpactPitchAngleDeg = results$pred_ImpactPitchAngleDeg * sds[['ImpactPitchAngleDeg']] + means[['ImpactPitchAngleDeg']],
                       pred_ImpactYawAngleDeg = results$pred_ImpactYawAngleDeg * sds[['ImpactYawAngleDeg']] + means[['ImpactYawAngleDeg']],
                       pred_ImpactPathAngleDeg = results$pred_ImpactPathAngleDeg * sds[['ImpactPathAngleDeg']] + means[['ImpactPathAngleDeg']])

#error of unscaled results
unscaled <- unscaled %>% mutate(error_ImpactHeadSpeedMph = test_ImpactHeadSpeedMph - pred_ImpactHeadSpeedMph,
                                error_ImpactAttackAngleDeg = test_ImpactAttackAngleDeg - pred_ImpactAttackAngleDeg,
                                error_ImpactPitchAngleDeg = test_ImpactPitchAngleDeg - pred_ImpactPitchAngleDeg,
                                error_ImpactYawAngleDeg = test_ImpactYawAngleDeg - pred_ImpactYawAngleDeg,
                                error_ImpactPathAngleDeg = test_ImpactPathAngleDeg - pred_ImpactPathAngleDeg)

#root mean squared error of unscaled 
rmse <- unscaled %>% summarise(rmse_ImpactHeadSpeedMph = sqrt(mean(error_ImpactHeadSpeedMph^2)),
                               rmse_ImpactAttackAngleDeg = sqrt(mean(error_ImpactAttackAngleDeg^2)),
                               rmse_ImpactPitchAngleDeg = sqrt(mean(error_ImpactPitchAngleDeg^2)),
                               rmse_ImpactYawAngleDeg = sqrt(mean(error_ImpactYawAngleDeg^2)),
                               rmse_ImpactPathAngleDeg = sqrt(mean(error_ImpactPathAngleDeg^2)))

#store results
results <- cbind(layer_one_neuron = i, rmse)
results_combined <- rbind(results_combined, results)

#}
#}
}

#results_combined1<- results_combined
#results_combined2<- results_combined


#print

# saveRDS(model, file = "nn_8_0_test.rda")

#8 and 8, 3 are performing the best at first scaling 0 to 1
#8, 5 are performing best with mean center and sd scaling

```

```{r , echo=FALSE, include = TRUE, warning = TRUE}

annotate_npc <- function(label, x, y, ...)
{
  ggplot2::annotation_custom(grid::textGrob(
    x = unit(x, "npc"), y = unit(y, "npc"), label = label, ...))
}

ggplot(unscaled, aes(x = test_ImpactHeadSpeedMph, y = pred_ImpactHeadSpeedMph)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse$rmse_ImpactHeadSpeedMph, 2)), 0.1, .95) + xlim(50,110) + ylim(50,110)

ggplot(unscaled, aes(x = test_ImpactAttackAngleDeg, y = pred_ImpactAttackAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse$rmse_ImpactAttackAngleDeg, 2)), 0.1, .95)  + xlim(-15,10) + ylim(-15,10)

ggplot(unscaled, aes(x = test_ImpactPitchAngleDeg, y = pred_ImpactPitchAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse$rmse_ImpactPitchAngleDeg, 2)), 0.1, .95) + xlim(10,50) + ylim(10,50)

ggplot(unscaled, aes(x = test_ImpactYawAngleDeg, y = pred_ImpactYawAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse$rmse_ImpactPitchAngleDeg, 2)), 0.1, .95) + xlim(-10,15) + ylim(-10,15)

ggplot(unscaled, aes(x = test_ImpactPathAngleDeg, y = pred_ImpactPathAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse$rmse_ImpactPitchAngleDeg, 2)), 0.1, .95) 

```

```{r , echo=FALSE, include = TRUE, warning = TRUE}

#ECPC test sample 
ECPC <- Data.Combined.7I %>% filter(Tags == "MB21" | Tags == "TCB") %>% group_by(Player, Tags) %>% summarise(Club.Speed.quad = mean(na.omit(Club.Speed.quad)), Angle.Of.Attack.quad = mean(na.omit(Angle.Of.Attack.quad)), Loft.quad = mean(na.omit(Loft.quad)), Face.To.Target.quad = mean(na.omit(Face.To.Target.quad)), Club.Path.quad = mean(na.omit(Club.Path.quad)), Lateral.Face.quad = mean(na.omit(Lateral.Face.quad)), Vertical.Face.quad = mean(na.omit(Vertical.Face.quad)), Ball.Speed.quad = mean(na.omit(Ball.Speed.quad)), Launch.Angle.quad = mean(na.omit(Launch.Angle.quad)), Side.Angle.quad = mean(na.omit(Side.Angle.quad)), Back.Spin.quad = mean(na.omit(Back.Spin.quad)),  Side.Spin.quad = mean(na.omit(Side.Spin.quad)))

#remove NA
ECPC <- ECPC %>% filter(!is.na(Club.Speed.quad), !is.na(Angle.Of.Attack.quad), !is.na(Loft.quad)) 

ECPC$Tags[ECPC$Tags == "MB21" ] <- "APEX_MB_21"
ECPC$Tags[ECPC$Tags == "TCB" ] <- "APEX_TCB_21"

colnames(ECPC) <- c("Player", "ClubFamilyName","ImpactHeadSpeedMph", "ImpactAttackAngleDeg", "ImpactPitchAngleDeg" , "ImpactYawAngleDeg", "ImpactPathAngleDeg", "ImpactHorizLocInch", "ImpactVertLocInch", "BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg", "BallBackSpinRpm", "BallSideSpinRpm")

ECPC <- ECPC %>% mutate(value = 1)  %>% spread(ClubFamilyName, value,  fill = 0)

#parameters for scaling/normalizing data
maxs <- apply(data, 2, max) 
mins <- apply(data, 2, min)
means <- apply(data[,1:12], 2, mean)
sds <- apply(data[,1:12], 2, sd)

#scaling to 0 to 1
#scaled <- as.data.frame(scale(data, center = mins, scale = maxs - mins))

#scaling to mean = 0 and sd = 1
scaled <- as.data.frame(cbind(scale(ECPC[,2:13], center = means, scale = sds), ECPC[,14:15], APEX_21 = 0, APEX_DCB_21 = 0, APEX_PRO_21 = 0))
scaled_input <- scaled %>% select(-ImpactHeadSpeedMph, -ImpactAttackAngleDeg, -ImpactPitchAngleDeg, -ImpactYawAngleDeg, -ImpactPathAngleDeg, -ImpactHorizLocInch, -ImpactVertLocInch)

#predictions for test set
pr.nn <- compute(model,scaled_input)

#organize actual vs. predictions
results <- data.frame(scaled$ImpactHeadSpeedMph, scaled$ImpactAttackAngleDeg, scaled$ImpactPitchAngleDeg, pr.nn$net.result[,1], pr.nn$net.result[,2], pr.nn$net.result[,3])
colnames(results) <- c("test_ImpactHeadSpeedMph", "test_ImpactAttackAngleDeg", "test_ImpactPitchAngleDeg", "pred_ImpactHeadSpeedMph", "pred_ImpactAttackAngleDeg", "pred_ImpactPitchAngleDeg")

#unscaling to mean = 0 and sd = 1
unscaled_ECPC <- data.frame(test_ImpactHeadSpeedMph = results$test_ImpactHeadSpeedMph * sds[['ImpactHeadSpeedMph']] + means[['ImpactHeadSpeedMph']],
                       test_ImpactAttackAngleDeg = results$test_ImpactAttackAngleDeg * sds[['ImpactAttackAngleDeg']] + means[['ImpactAttackAngleDeg']],
                       test_ImpactPitchAngleDeg = results$test_ImpactPitchAngleDeg * sds[['ImpactPitchAngleDeg']] + means[['ImpactPitchAngleDeg']],
                       pred_ImpactHeadSpeedMph = results$pred_ImpactHeadSpeedMph * sds[['ImpactHeadSpeedMph']] + means[['ImpactHeadSpeedMph']],
                       pred_ImpactAttackAngleDeg = results$pred_ImpactAttackAngleDeg * sds[['ImpactAttackAngleDeg']] + means[['ImpactAttackAngleDeg']],
                       pred_ImpactPitchAngleDeg = results$pred_ImpactPitchAngleDeg * sds[['ImpactPitchAngleDeg']] + means[['ImpactPitchAngleDeg']])

#error of unscaled results
unscaled_ECPC <- unscaled_ECPC %>% mutate(error_ImpactHeadSpeedMph = test_ImpactHeadSpeedMph - pred_ImpactHeadSpeedMph,
                                error_ImpactAttackAngleDeg = test_ImpactAttackAngleDeg - pred_ImpactAttackAngleDeg,
                                error_ImpactPitchAngleDeg = test_ImpactPitchAngleDeg - pred_ImpactPitchAngleDeg)


#root mean squared error of unscaled 
rmse_ECPC <- unscaled_ECPC %>% summarise(rmse_ImpactHeadSpeedMph = sqrt(mean(error_ImpactHeadSpeedMph^2)),
                               rmse_ImpactAttackAngleDeg = sqrt(mean(error_ImpactAttackAngleDeg^2)),
                               rmse_ImpactPitchAngleDeg = sqrt(mean(error_ImpactPitchAngleDeg^2)))

#store results
results_ECPC <- cbind(layer_one_neuron = 8, rmse_ECPC)

ggplot(unscaled_ECPC, aes(x = test_ImpactHeadSpeedMph, y = pred_ImpactHeadSpeedMph)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse_ECPC$rmse_ImpactHeadSpeedMph, 2)), 0.1, .95) 

ggplot(unscaled_ECPC, aes(x = test_ImpactAttackAngleDeg, y = pred_ImpactAttackAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse_ECPC$rmse_ImpactAttackAngleDeg, 2)), 0.1, .95)  

ggplot(unscaled_ECPC, aes(x = test_ImpactPitchAngleDeg, y = pred_ImpactPitchAngleDeg)) + geom_point() + geom_smooth(method = "lm") + annotate_npc(paste("RSME = ", round(rmse_ECPC$rmse_ImpactPitchAngleDeg, 2)), 0.1, .95) 

```



## Auto ML using H20
```{r , echo=FALSE, include = TRUE, warning = TRUE}

#library(h2o)
#library(dplyr)
#library(ggplot2)
h2o.init()



# import the cars dataset:
data <- h2o.importFile("test.csv")

# set the predictor names and the response column name
x <- c("BallSpeedMph", "BallLaunchAngleDeg", "BallSideAngleDeg", "BallBackSpinRpm",  "BallSideSpinRpm", "ClubFamilyName")
y <- c("ImpactHeadSpeedMph")

# split into train and validation sets
splits <- h2o.splitFrame(data =  data, ratios = 0.8, seed = 1234)
train <- splits[[1]]
valid <- splits[[2]]

# Run AutoML for 20 base models
aml <- h2o.automl(x = x, y = y,
                  training_frame = train,
                  max_models = 20,
                  #include_algos = c("Deeplearning", "GBM"),
                  seed = 1)


lb <- h2o.get_leaderboard(object = aml, extra_columns = "ALL", extra)
lb

m <- h2o.get_best_model(aml)

my_local_model <- h2o.download_model(m)

model <- h2o.loadModel("StackedEnsemble_AllModels_1_AutoML_1_20230707_220426")

print(model)

result_predict <- predict(model,valid, na.action = na.omit)
Engage_Data <- cbind(as.data.frame(valid$ImpactHeadSpeedMph),as.data.frame(result_predict))
colnames(Engage_Data) <- c("Actual", "Predicted")
Engage_Data <- as.data.frame(Engage_Data)

error <- (Engage_Data$Actual- Engage_Data$Predicted)
Engage_Data <- cbind(Engage_Data,error)

Engage_Data <- Engage_Data %>% na.omit()

rmse1<-sqrt(mean(Engage_Data$error^2))
rmse1

MSE.mem <- sum((Engage_Data$error)^2)/nrow(valid)
MSE.mem

ggplot(Engage_Data, aes(x = Actual, y = Predicted)) + geom_point() + geom_smooth(method = "lm") + annotate(geom="text", x=70, y=100, label= paste("MSE = ", round(MSE.mem, 2))) + annotate(geom="text", x=70, y=95, label= paste("RMSE = ", round(rmse1, 2)))

```

# Notes, model does a poor job predicting low pitch, we do not have any data in this area?

